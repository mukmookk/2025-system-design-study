# 9장 URL 단축 서비스 설계 (1.design.md)

> 목표: **대규모 트래픽(읽기 중심)** 환경에서 **고유한 단축 URL 생성**과 **빠른 리다이렉트**를 제공하는 URL 단축 서비스를 설계한다.

---

## 9.1 실제 활용 사례

URL 단축 서비스는 “긴 URL을 짧게” 만드는 것 이상으로, **추적(Analytics)** 과 **브랜딩(Branding)**, **오프라인 채널 연결**의 역할을 한다.

| 활용 분야 | 구체적 예시 | 왜 단축이 유리한가 |
|---|---|---|
| 소셜 미디어 공유 | 트위터/인스타 게시물 링크 | 글자 수 제한, 미관, 공유 편의 |
| 제휴 마케팅 | `campaign=abc&affiliate=xyz` 포함 링크 | 클릭 수·전환 추적, 캠페인별 성과 분석 |
| 이메일 마케팅 | 뉴스레터 CTA 버튼 | 클릭률(CTR) 측정, 링크 가독성 |
| QR 코드 | 포스터/명함 QR | URL이 짧을수록 QR 코드가 단순해져 인식률↑ |
| 인쇄 매체/오프라인 | 전단지, 옥외 광고 | 사람이 직접 입력 가능(오타 감소) |
| 내부 공유 링크 | 사내 위키, 대시보드 공유 | 긴 SSO/파라미터 URL을 단순화 |
| 모바일 애플리케이션 | 딥링크(앱 열기) | 플랫폼별 분기(iOS/Android), 추적 |
| 커스터마이징/브랜딩 | `t.co`, `bit.ly`, `nyti.ms` | 신뢰도, 브랜드 일관성, 피싱 방지 |

---

## 9.1.1 기능적 요구사항

### 기본 기능
1. **생성(Create)**: 긴 URL을 받으면 단축 URL을 생성해 반환한다.
2. **해석(Resolve/Redirect)**: 단축 URL을 받으면 원본 URL을 찾아 리다이렉트한다.
3. **고유성(Uniqueness)**: 단축 URL은 겹치지 않아야 한다.
4. **길이 고정(Fixed Length)**: 단축 URL은 일정한 길이를 유지한다(예: 7자리).

### 확장 기능(선택)
- **만료(Expiration)**: 특정 시각 이후 리다이렉트 불가/대체 페이지 제공
- **커스텀 별칭(Custom Alias)**: 사용자가 원하는 짧은 경로 제공(예: `/my-event`)
- **클릭 통계(Analytics)**: 전체 클릭 수/시간대/리퍼러/디바이스 등
- **악성 URL 방지**: 블랙리스트/평판 기반 차단
- **A/B 링크**: 동일 단축 링크가 조건에 따라 다른 원본으로 리다이렉트

---

## 9.1.2 비기능적 요구사항

| 항목 | 목표/설명 |
|---|---|
| 가용성(Availability) | 리다이렉트는 핵심 기능 → 99.99% 이상 목표 |
| 확장성(Scalability) | 장기적으로 수십~수백억 URL 저장, 트래픽 10배 증가 대응 |
| 응답속도(Latency) | 리다이렉트는 체감 성능에 직접 영향 → P95 50ms 내 목표(캐시 히트 기준) |
| 일관성(Consistency) | 생성 직후 바로 해석 가능해야 함(강한 일관성 요구가 흔함) |
| 내구성(Durability) | 생성된 매핑은 유실되면 안 됨(데이터 손실 = 서비스 신뢰 붕괴) |
| 신뢰성(Reliability) | 부분 장애(DB/캐시)에도 기능 유지(우회 경로/복구 가능) |

---

## 9.2 API 설계

> 여기서는 **최소 API**를 정의하고, 운영/확장을 고려해 필드를 확장한다.

### 9.2.1 단축 URL 생성

**POST /shorturl**

요청(예시):
```json
{
  "longUrl": "https://example.com/very/long/path?campaign=abc",
  "customAlias": "optional-alias",
  "expireAt": "2026-12-31T23:59:59Z",
  "createdBy": "user_123"
}
```

응답(예시):
```json
{
  "shortUrl": "https://urlshortener.com/keoeNx",
  "shortCode": "keoeNx",
  "expireAt": "2026-12-31T23:59:59Z"
}
```

설계 포인트:
- `customAlias`가 있으면 **중복 검사 + 예약 처리** 필요(이름 충돌 방지).
- `expireAt`이 있으면 리다이렉트 시 만료 여부 확인.
- 멱등성(선택): `Idempotency-Key` 헤더로 **중복 생성 방지** 가능.

---

### 9.2.2 단축 URL 해석(리다이렉트)

**GET /shorturls/{shortCode}**

실제 서비스 동작:
- `shortCode`로 원본 URL을 조회한 뒤
- `301(Moved Permanently)` 또는 `302(Found)`로 리다이렉트

> 일반적으로 “단축 서비스”는 캐시/통계 등으로 인해 302를 쓰는 경우가 많다(정책에 따라 선택).

응답(개념):
- 서버 내부적으로 원본 URL을 찾고 `Location` 헤더에 담아 리다이렉트

---

## 9.3 계산으로 문제 규모 파악

### 9.3.1 단축 URL 문자 집합
- a-z(26) + A-Z(26) + 0-9(10) = 62개  
(문제 서술에는 `- . _ ~` 포함 66개도 가능하지만, 여기서는 **62개만 사용**)

---

### 9.3.2 서비스 규모 가정
- 전체 사용자: 10억
- 생성 사용자: 10%(1억)
- 하루 생성량: 1억
- 10년 누적: `365 * 10 * 1억 = 3650억`

---

### 9.3.3 단축 코드 길이 산정
- 6자리: `62^6 ≈ 500억` → 부족
- 7자리: `62^7 ≈ 3.5조` → 목표(3650억) 대비 충분

따라서 **7자리 고정**이 합리적.

---

### 9.3.4 저장 공간 산정
각 레코드(예시):
- short URL: 20B
- long URL: 1000B
- created_at: 10B
- updated_at: 10B
- created_by: 20B  
→ 합계 1060B, 보수적으로 **1500B**로 반올림

총 데이터:
- `3650억 * 1500B ≈ 500TB`
- 복제 3개: **1.5PB**

---

### 9.3.5 읽기/쓰기 RPS
- 쓰기: `1억 / 86400 ≈ 1157 RPS` → 근사 1000 RPS
- 읽기: 일반적으로 쓰기의 100배 가정 → **100,000 RPS**

> 결론: **읽기 성능(캐시/CDN)이 설계의 중심**.

---

# 9.4 시스템 설계

## 9.4.1 핵심 문제

> **“어떻게 하면 겹치지 않는 고유한 단축 URL을 빠르고 안정적으로 대규모 환경에서 생성할 수 있을까?”**

이 문제는 단순 문자열 생성이 아니라 아래를 동시에 만족해야 한다:
- 전역 고유성(충돌 없음)
- 낮은 생성 지연(쓰기 경로 빠르게)
- DB 부하 최소화(생성마다 조회/락을 피하기)
- 장애 허용(특정 서버가 죽어도 전체 중단 X)
- 수평 확장(서버 늘리면 처리량 선형 증가)

---

## 9.4.2 고유 단축 URL 생성 전략 비교

### 방법 1) 무작위(Random) 생성 + 중복 검사

#### 동작
1. 랜덤 shortCode 생성(7자리 Base62)
2. DB에서 존재 여부 확인
3. 없으면 저장, 있으면 재시도

#### 장점
- 구현 단순
- 별도 ID 인프라 필요 없음

#### 단점(대규모에서 치명적)
- **최소 1회 DB 조회**가 매 요청마다 필요
- 충돌 시 재시도 → **지연 시간 예측 불가**
- 동시성 문제: 두 요청이 동일 코드 생성 가능  
  - 해결책: `putIfAbsent` 같은 **원자적 삽입**이 필요(모든 DB가 지원하진 않음)
  - 또는 저장 후 검증 조회(추가 읽기 비용)

> 결론: 트래픽이 커질수록 비용/지연이 누적되어 비효율.

---

### 방법 2) 해시 기반(MD5 등) + 일부 비트 사용

#### 아이디어
- longUrl → MD5(128bit)
- 7자리 Base62에 필요한 42bit만 추출
- Base62로 변환해 shortCode 생성

#### 장점
- 동일 longUrl → 동일 shortCode (중복 저장 감소)
- 생성 시 DB 조회가 필요 없을 수 있음

#### 단점
- 128bit 전체를 쓰지 않으면 **충돌 가능성**은 남는다
- 충돌 처리 로직(salt 재해시, 다른 구간 사용 등) 필요
- 충돌을 줄이기 위해 비트를 늘리면 **단축 코드 길이 증가**

> 결론: “확률적 유일성”이라 강한 보장이 필요한 서비스에는 부담.

---

### 방법 3) 단일 카운터(증가 숫자)

#### 아이디어
- 1,2,3… 증가하는 숫자 → Base62 변환

#### 장점
- 충돌 0%
- 매우 빠름(증가 연산)

#### 치명적 단점
- 카운터 서버가 단일 장애 지점(SPOF)
- 분산 확장 시 호스트ID/시간/시퀀스 조합이 필요하지만  
  비트 할당 한계로 **호스트 수 제한**, **ms당 시퀀스 제한** 문제가 발생

> 결론: 작은 서비스엔 가능하지만 대규모 분산 환경에서는 불안정.

---

### 방법 4) 분산 카운터 + 범위 할당(Range Allocation) ★ 추천

#### 핵심 아이디어
- 전체 ID 공간(예: 0 ~ 3.5조)을 **range(구간)** 로 나눔
- 카운터 서버가 range를 “미리” 할당받아, 그 안에서만 증가시켜 ID 생성
- range 소진 시 새 range를 요청

예: K=1,000,000(100만)인 경우
- R1: [0, 1M)
- R2: [1M, 2M)
- …
- 전체 필요 range 수 ≈ 3.5조 / 100만 = 350만 개

#### 구성 요소
| 컴포넌트 | 역할 |
|---|---|
| Range 할당 서버 | range를 원자적으로 배정(중복 배정 금지) |
| 카운터 서버 | 배정된 range 안에서 ID를 증가시키며 생성 |
| DB | (shortCode → longUrl) 매핑 저장 |
| 캐시 | 리다이렉트 읽기 성능 최적화 |

#### 동작 흐름(생성)
1. 카운터 서버가 Range 할당 서버에 range 요청
2. Range 할당 서버가 다음 range를 배정(원자적 갱신)
3. 카운터 서버는 메모리에서 `nextId++` 만 수행
4. 생성된 숫자 ID를 Base62로 변환해 shortCode 생성
5. DB에 매핑 저장 후 응답

#### 장점
- 충돌 0% (전역 고유성)
- 생성이 빠름(대부분 메모리 증가 연산)
- 수평 확장 가능(카운터 서버를 늘리면 처리량↑)
- DB 조회/재시도 루프가 없다(지연 예측 가능)

#### 남는 문제와 해결
1) **range 소진**  
- 카운터 서버가 새 range를 요청하면 됨

2) **카운터 서버 다운**  
- 할당된 range 일부가 “사용되지 않고” 손실될 수 있음  
- 하지만 전체 공간 대비 극히 일부이며, 링크 고유성에는 영향 없음  
  (연속성보다 유일성이 더 중요)

3) **range 손실 최소화(체크포인트)**  
- 카운터 서버가 N개 발급마다 현재 위치를 Range 서버에 기록  
- 재시작 시 마지막 기록 지점 + N부터 재개

4) **Range 할당 서버 SPOF**  
- 트래픽이 작다(할당 요청은 range 교체 시점에만 발생)  
- 따라서 ZooKeeper/etcd 같은 합의 기반 스토어로 HA 구성 가능

---

## 9.4.3 Base62 인코딩(숫자 → 7자리 코드)

숫자 ID를 짧게 표현하기 위해 Base62를 사용한다.

- 문자 집합 예: `0-9`, `A-Z`, `a-z` (총 62개)

변환 개념:
- `id`를 62로 나눠 나머지를 문자로 매핑
- 몫을 다시 62로 나누는 과정을 반복

예시(개념):
- `9234529445` → Base62 digits → `keoeNx`
- 최종 URL: `https://urlshortener.com/keoeNx`

> 7자리 고정이 필요하다면, 부족한 자릿수는 앞을 `0`(또는 특정 문자)로 패딩한다.

