# 발행/구독(Pub/Sub) 시스템 설계

## 1. 개요

발행/구독(Publish/Subscribe, Pub/Sub)은 **메시지를 생성하는 주체(Producer/Publisher)** 와  
**메시지를 소비하는 주체(Consumer/Subscriber)** 를 직접 연결하지 않고,  
**브로커(Broker) 또는 토픽/채널(Topic/Channel)** 을 매개로 비동기 통신하는 메시징 패턴이다.

### 1.1 Pub/Sub의 핵심 가치
- **느슨한 결합(Loose Coupling)**: 생산자/소비자 간 직접 의존 제거
- **확장성(Scalability)**: 생산자/소비자를 독립적으로 수평 확장
- **비동기 처리(Async)**: 처리 지연을 큐/브로커가 흡수
- **내결함성(Resilience)**: 소비자 장애 시에도 메시지를 보관/재처리 가능(구성에 따라)

---

## 2. 구성요소 및 역할

### 2.1 Publisher(Producer)
- 메시지(Event)를 생성해 **Topic/Channel** 로 발행
- 책임 범위
  - 메시지 스키마(형식) 준수
  - 키(key) 선택(파티셔닝, 순서에 영향)
  - 전송 보장(재시도, idempotency 등)

### 2.2 Broker / Message Bus
- 메시지의 **수신, 저장, 전달(라우팅), 재전달** 을 담당
- 예: Kafka, RabbitMQ, NATS, Pulsar, Redis Pub/Sub 등

### 2.3 Subscriber(Consumer)
- Topic을 구독하고 메시지를 처리
- 책임 범위
  - 메시지 처리 로직
  - 오프셋/ACK 관리
  - 실패 처리(재시도, DLQ, 멱등성)

### 2.4 Topic/Channel
- 메시지가 흘러가는 논리적 스트림
- 설계 시 고려
  - 토픽 분리 기준(도메인/이벤트 타입/소유팀)
  - 파티션(병렬성/순서)

---

## 3. 설계 목표(요구사항 정의)

Pub/Sub 설계는 “무엇을 보장해야 하는가?”를 명확히 해야 한다.

### 3.1 처리량(Throughput) vs 지연(Latency)
- 높은 TPS/대용량 로그 → 처리량 중심
- 알림/실시간 반응 → 지연 중심

### 3.2 메시지 전달 보장(Delivery Semantics)
- **At-most-once**: 유실 가능, 중복 없음(빠름)
- **At-least-once**: 중복 가능, 유실 최소(일반적)
- **Exactly-once**: 중복/유실 모두 최소(구현/운영 복잡)

> 실무 대부분은 **At-least-once + 멱등 처리** 조합으로 안정성을 만든다.

### 3.3 순서 보장(Ordering)
- 전역 순서(Global ordering)는 비싸다.
- 보통은 **키 기반 파티션 내 순서**(per-key ordering)로 충분하게 설계한다.

### 3.4 내구성(Durability)
- 메시지를 디스크에 저장할지(로그 기반)
- 메모리 기반으로만 처리할지(초저지연, 유실 허용)

---

## 4. 토픽/이벤트 모델링

### 4.1 이벤트 vs 커맨드
- **Event**: “이미 발생한 사실” (예: OrderPlaced)
- **Command**: “무언가 해달라” (예: CreateOrder)

Pub/Sub는 보통 **이벤트 중심**으로 구성하는 것이 자연스럽다.

### 4.2 토픽 설계 원칙
- **도메인 기준**으로 토픽을 나누되, 팀/서비스 소유권도 고려
- 이벤트 타입별 분리:
  - `order-events`, `payment-events`
- 단일 토픽에 여러 이벤트를 섞는 경우(권장X)라면 최소한:
  - `eventType` 필드로 구분
  - 스키마 호환 정책을 강하게 관리

### 4.3 파티션(Partition) 설계
- 파티션은 **병렬 처리 단위**이자 **순서 보장 단위**다.
- 키 설계가 곧 파티션 설계다.

**키 선택 가이드**
- 주문 처리 순서가 중요하면 `orderId`
- 사용자 단위 순서가 중요하면 `userId`
- 특정 서버/세션 단위면 `sessionId`

**안티패턴**
- 키를 랜덤 UUID로 잡아 순서가 필요했던 도메인 요구를 깨버림
- 키를 너무 소수 값(예: 국가코드)로 잡아 핫 파티션 발생

---

## 5. 메시지 형식과 스키마 관리

### 5.1 스키마 버전 전략
- 하위 호환(Backward compatible) 중심으로 설계
- 필드 추가는 가능하되, 필드 삭제/타입 변경은 매우 주의

**권장 규칙**
- 새 필드는 optional + default 제공
- enum 확장은 허용하되, 의미 변경 금지
- 소비자는 “모르는 필드”를 무시할 수 있어야 함

### 5.2 메시지 구조 예시(권장)
- 메타데이터와 payload를 분리
- 추적/운영을 위한 필드 포함

예:
- `eventId` (UUID)
- `eventType`
- `occurredAt` (생성 시각)
- `producer` (서비스명)
- `traceId` / `correlationId`
- `payload` (도메인 데이터)

---

## 6. 소비자 처리 모델

### 6.1 Consumer Group(경쟁 소비) vs Fan-out(브로드캐스트)
- **Consumer Group(Queue-like)**: 여러 소비자가 작업을 분산 처리(스케일 아웃)
- **Fan-out(Pub/Sub)**: 여러 서비스가 동일 이벤트를 각자 처리(마이크로서비스 이벤트)

### 6.2 ACK / Offset 커밋 전략
- **처리 후 커밋(Post-processing commit)**: 안전(중복 가능)
- **커밋 후 처리(Pre-processing commit)**: 빠르지만 유실 가능

대부분은 **처리 성공 후 커밋**을 기본으로 한다.

### 6.3 멱등성(Idempotency)
At-least-once에서는 중복이 발생할 수 있으므로 소비자는 멱등해야 한다.

**멱등 처리 전략**
- `eventId` 기반 중복 처리 방지(Processed Event Table/Redis)
- DB upsert / unique constraint 활용
- 외부 호출은 idempotency key 사용

---

## 7. 실패 처리(재시도/백오프/DLQ)

### 7.1 재시도 정책
- 즉시 재시도는 폭발적인 부하를 만들 수 있음
- 지수 백오프(Exponential Backoff) + 지터(Jitter) 권장

### 7.2 Poison Message(독성 메시지)
특정 메시지가 항상 실패하면 파이프라인 전체가 막힌다.

**해결**
- 최대 재시도 횟수 도입
- 실패 메시지를 별도로 격리(DLQ)하고 본 흐름은 계속 진행

### 7.3 DLQ(Dead Letter Queue)
- 처리 실패 메시지를 저장하는 별도 토픽/큐
- 운영 시 필수 고려사항
  - 원인 분석을 위한 오류 코드/스택트레이스/리트라이 횟수 기록
  - 재처리 도구/프로세스 준비(Replay)

---

## 8. 확장성/성능 설계

### 8.1 Backpressure(역압)
소비 속도 < 생산 속도일 때 시스템이 무너진다.

**대응 방식**
- 소비자 수(인스턴스) 증가
- 파티션 수 증가(병렬성 확대)
- 처리 로직 최적화(배치 처리, I/O 분리)
- 브로커 적체 모니터링(lag/queue depth)

### 8.2 배치 처리와 폴링 튜닝(브로커별 상이)
- 배치 크기 조정(Throughput ↑, Latency ↑ 가능)
- 폴링 주기/프리페치(prefetch) 조정
- 소비자 처리 시간 대비 브로커 세션 타임아웃/리밸런싱 방지

### 8.3 순서/성능 트레이드오프
- 강한 순서 보장 → 병렬성 감소
- 병렬성 확대 → 순서 보장 범위 축소(per-key로 제한)

---

## 9. 신뢰성 설계(중복/유실/정합성)

### 9.1 Exactly-once를 “목표”로 둘 때의 현실
Exactly-once는 브로커 기능만으로 끝나지 않고,
**소비자 side-effect(DB write, 외부 API 호출)** 까지 포함해야 의미가 있다.

실무적 접근:
- 브로커는 at-least-once
- 소비자는 멱등 처리 + 트랜잭션 경계 명확화
- 필요하면 outbox/inbox 패턴으로 정합성 강화

### 9.2 Outbox 패턴(이벤트 발행 정합성)
DB 변경과 이벤트 발행의 원자성을 보장하려는 패턴

- 트랜잭션 내에서 Outbox 테이블에 이벤트 저장
- 별도 프로세스가 Outbox를 읽어 브로커로 발행
- 발행 성공 시 Outbox 상태 업데이트

장점: DB 업데이트와 이벤트 발행 사이의 유실/불일치 최소화  
단점: 구현/운영 복잡도 증가

---

## 10. 운영/관측(Observability)

### 10.1 핵심 운영 지표
- 생산 TPS / 소비 TPS
- Lag(미처리 메시지 수)
- 실패율(재시도율, DLQ 유입률)
- 처리 지연(End-to-end latency)
- 리밸런싱/재연결 빈도

### 10.2 추적(Tracing)과 상관관계(Correlation)
- `traceId`, `correlationId`를 메시지 메타에 포함
- 분산 트레이싱(APM)에서 이벤트 흐름을 추적 가능하게 설계

---

## 11. 보안 및 접근 제어

- 토픽 단위 ACL/RBAC
- 생산자/소비자 계정 분리
- 인증(SSL/SASL/OAuth 등) + 암호화(전송 구간)
- 민감 데이터의 토픽 분리 또는 필드 마스킹/암호화

---

## 12. 안티 패턴(실무에서 자주 터지는 부분)

- “무조건 Exactly-once”를 목표로 잡고 복잡도 폭발
- 토픽을 과도하게 세분화하여 운영 비용 증가
- 키 설계를 잘못해 핫 파티션 발생
- DLQ 없이 무한 재시도로 파이프라인 정지
- 메시지에 버전/스키마 관리 없이 필드 변경
- 소비자가 멱등하지 않아 중복 처리로 데이터 오염