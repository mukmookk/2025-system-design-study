# Amazon Kinesis

Amazon Kinesis는 **AWS에서 제공하는 완전관리형(Managed) 실시간 스트리밍 플랫폼**이다.  
대규모 이벤트/로그/메트릭 데이터를 **실시간으로 수집·처리·전달**하는 데 목적이 있다.

Kafka와 유사한 Pub/Sub 기반 스트리밍 플랫폼이지만,
**운영 책임을 AWS에 위임**하고 AWS 서비스들과 강하게 통합된 것이 가장 큰 특징이다.

---

## 1. Kinesis를 쓰는 이유 (도입 배경)

### 1.1 해결하려는 문제
- 대규모 이벤트/로그를 안정적으로 수집
- 실시간 처리 또는 near-real-time 분석
- 인프라 운영 부담 최소화
- AWS 서비스와의 자연스러운 연계

### 1.2 Kinesis의 핵심 장점
- 서버/브로커 직접 운영 불필요
- 자동 확장(특히 Kinesis Data Streams On-Demand)
- IAM 기반 보안/권한 관리
- Lambda, Firehose, Analytics와의 높은 결합성

### 1.3 Kafka와의 큰 차이
- Kafka: **운영 자유도 ↑ / 복잡도 ↑**
- Kinesis: **운영 편의성 ↑ / 제어 자유도 ↓**

---

## 2. Kinesis 구성요소 개요

Amazon Kinesis는 하나의 서비스가 아니라 **여러 하위 서비스의 묶음**이다.

### 2.1 Kinesis Data Streams (KDS)
- 실시간 이벤트 스트리밍의 핵심
- Kafka의 “토픽 + 파티션”과 유사
- 데이터는 **Shard** 단위로 분산 저장

### 2.2 Kinesis Data Firehose
- 스트림 데이터를 S3, Redshift, OpenSearch 등으로 **자동 적재**
- 실시간 처리보다는 **전송/적재 목적**

### 2.3 Kinesis Data Analytics
- SQL 또는 Apache Flink 기반 스트림 처리
- 스트림 집계/변환/조인 수행

### 2.4 Kinesis Video Streams
- 영상/미디어 스트리밍 전용 (일반 로그/이벤트와는 별도)

이 문서에서는 **Kinesis Data Streams 중심**으로 설명한다.

---

## 3. Kinesis Data Streams 핵심 구조

### 3.1 Stream
- 데이터 이벤트의 논리적 단위
- Kafka의 Topic에 대응

### 3.2 Shard (가장 중요한 개념)
- Kinesis의 **확장성과 순서 보장 단위**
- 각 Shard는:
  - 초당 **1MB write / 2MB read**
  - 초당 **1000 records write**
- Shard 내부에서는 **순서 보장**

> Kafka의 Partition ≒ Kinesis의 Shard

### 3.3 Record
- 스트림에 저장되는 데이터 단위
- 구성 요소:
  - partition key
  - data payload
  - sequence number

---

## 4. 데이터 흐름 (End-to-End)

### 4.1 Producer
- PutRecord / PutRecords API로 데이터 전송
- partition key를 기준으로 Shard 결정

### 4.2 Stream (Shard)
- 데이터는 append-only 방식으로 저장
- 일정 기간(retention) 동안 유지

### 4.3 Consumer
- Shard 단위로 데이터 읽기
- 방식:
  - Kinesis Client Library(KCL)
  - Enhanced Fan-Out
  - Lambda Trigger

---

## 5. Shard & Partition Key 설계 (핵심)

### 5.1 Partition Key 역할
Partition Key는 **Shard 선택 기준**이다.

- 같은 partition key → 같은 shard → 순서 보장
- 다른 partition key → 다른 shard → 병렬 처리

### 5.2 좋은 Partition Key 설계
- 데이터가 고르게 분산될 수 있는 값
- 순서가 필요한 범위의 식별자

예:
- 주문 단위 순서 필요 → orderId
- 사용자 단위 순서 필요 → userId

### 5.3 안티패턴
- partition key 값이 소수(예: 국가 코드)
- timestamp 기반 key
- 랜덤 key 사용 후 “순서 필요” 요구 발생

---

## 6. 처리 모델 & 소비 방식

### 6.1 Standard Consumer (폴링 기반)
- GetRecords API로 주기적 폴링
- 단순하지만 읽기 TPS 제한 존재

### 6.2 Enhanced Fan-Out (EFO)
- Shard당 Consumer 전용 읽기 대역폭 제공
- 지연 감소 / 다수 소비자에 유리
- 비용 증가

### 6.3 Lambda Consumer
- Lambda가 Shard를 자동으로 읽어 이벤트 처리
- 운영이 매우 간단
- 복잡한 상태 관리에는 부적합