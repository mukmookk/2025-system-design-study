## 4.1 DNS 이해

DNS(Domain Name System)는 사람이 읽기 쉬운 도메인 이름(예: `www.example.com`)을  
네트워크 통신에 필요한 IP 주소(예: `93.184.216.34`)로 변환하는 **분산형 네임 매핑 시스템**이다.  

DNS는 인터넷의 전화번호부 역할을 수행하며, 웹 서비스, 이메일, API 서버 요청 등  
모든 네트워크 애플리케이션에서 기본적으로 사용되는 핵심 인프라이다.

DNS는 단순한 문자열 치환 기능이 아니라 **전 세계적으로 분산된 계층 구조 + 캐싱 시스템 + 다양한 리소스 레코드**를 기반으로 동작한다.

DNS의 핵심 구성 요소는 다음과 같다.

### 목차

- [4.1 DNS 이해](#41-dns-이해)
  - [목차](#목차)
  - [4.1.1 DNS 구성 요소](#411-dns-구성-요소)
    - [1) 도메인 계층 구조 (Domain Hierarchy)](#1-도메인-계층-구조-domain-hierarchy)
    - [2) 네임서버(Name Server)](#2-네임서버name-server)
    - [3) DNS 리소스 레코드 (Resource Record, RR)](#3-dns-리소스-레코드-resource-record-rr)
    - [4) DNS 리졸버(Resolver)](#4-dns-리졸버resolver)
  - [4.1.2 DNS 쿼리](#412-dns-쿼리)
    - [DNS 쿼리 흐름 개요](#dns-쿼리-흐름-개요)
    - [재귀 쿼리 (Recursive Query)](#재귀-쿼리-recursive-query)
    - [반복 쿼리 (Iterative Query)](#반복-쿼리-iterative-query)
    - [DNS 쿼리 예시: 사용자가 `https://game.daum.net/` 에 접속하는 실제 흐름](#dns-쿼리-예시-사용자가-httpsgamedaumnet-에-접속하는-실제-흐름)
      - [1) Client → Resolver](#1-client--resolver)
      - [2) Resolver → Root Server](#2-resolver--root-server)
      - [3) Resolver → .net TLD Server](#3-resolver--net-tld-server)
      - [4) Resolver → Authoritative DNS (ns1.daum.net)](#4-resolver--authoritative-dns-ns1daumnet)
      - [5) Resolver → Client](#5-resolver--client)
    - [DNS 이후의 실제 연결 과정](#dns-이후의-실제-연결-과정)
    - [추가 설명: 왜 Authoritative가 daum.net 기준인가?](#추가-설명-왜-authoritative가-daumnet-기준인가)
    - [정리](#정리)
  - [4.1.3 운영 환경에서 도메인 사용이 표준인 이유](#413-운영-환경에서-도메인-사용이-표준인-이유)
    - [1. IP 변경에 대한 유연성](#1-ip-변경에-대한-유연성)
    - [2. 로드밸런싱 및 고가용성(HA) 구현](#2-로드밸런싱-및-고가용성ha-구현)
    - [3. 인프라 구성 요소에 대한 추상화(Abstract Layer)](#3-인프라-구성-요소에-대한-추상화abstract-layer)
    - [4. 네트워크 정책 및 보안 구성에서 필수적인 표준](#4-네트워크-정책-및-보안-구성에서-필수적인-표준)
    - [5. DNS 자체는 캐싱 구조로 매우 빠름](#5-dns-자체는-캐싱-구조로-매우-빠름)
- [4.2 DNS의 확장성 · 신뢰성 · 일관성](#42-dns의-확장성--신뢰성--일관성)
  - [4.2.1 확장성(Scalability)](#421-확장성scalability)
  - [4.2.2 신뢰성(Reliability)](#422-신뢰성reliability)
  - [4.2.3 일관성(Consistency)](#423-일관성consistency)

---

### 4.1.1 DNS 구성 요소

DNS는 크게 **도메인 계층 구조**, **네임서버**, **리소스 레코드(RR)**, **리졸버(Resolver)** 로 이루어진다.

#### 1) 도메인 계층 구조 (Domain Hierarchy)

DNS는 계층적 트리 구조로 구성되며, 위에서 아래로 내려갈수록 구체적인 도메인을 표현한다.

```
Root (.)
└── Top-Level Domain (.com, .net, .kr)
└── Second-Level Domain (example)
└── Subdomain (www)
```

- **Root 도메인(.)**  
  DNS 계층 최상위 노드. 전 세계 13개의 루트 서버 클러스터가 존재함.
- **TLD (Top-Level Domain)**  
  `.com`, `.org`, `.kr` 등 최상위 도메인.
- **Second-Level Domain**  
  `example.com` 중 `example`에 해당.
- **Subdomain**  
  `www.example.com` 중 `www`에 해당.

도메인의 구조는 DNS가 효율적이고 확장성 있게 동작하도록 설계된 기반이다.

---

#### 2) 네임서버(Name Server)

도메인의 정보를 저장하고, DNS 쿼리에 응답하는 서버이다.  
역할에 따라 다음과 같이 구분된다.

| 네임서버 유형 | 설명 |
|---------------|------|
| **Root Name Server** | DNS 최상위. TLD 서버의 위치 정보를 제공 |
| **TLD Name Server** | `.com`, `.kr` 등 특정 TLD를 담당 |
| **Authoritative Name Server** | 특정 도메인의 실제 IP(A 레코드 등)를 보관 |
| **Recursive Resolver** | 클라이언트 대신 전체 DNS 조회 과정을 수행하고 캐싱 |

특징 요약:

- **권한 있는 서버(Authoritative)**: 해당 도메인의 “정답”을 제공  
- **재귀 DNS(Resolver)**: Root → TLD → Authoritative 순으로 조회하며 최종 IP를 가져옴

---

#### 3) DNS 리소스 레코드 (Resource Record, RR)

DNS는 각 도메인에 대해 다양한 정보를 **레코드 형태**로 저장한다.  
대표적인 RR은 다음과 같다.

| 레코드 | 설명 | 예시 |
|--------|------|-------|
| **A** | 도메인을 IPv4 주소로 매핑 | `example.com → 93.184.216.34` |
| **AAAA** | 도메인을 IPv6 주소로 매핑 | `example.com → 2606:2800:220:1::...` |
| **NS** | 해당 도메인의 권한 네임서버 정보 | `ns1.example.com` |
| **CNAME** | 별칭 도메인을 실제 도메인으로 매핑 | `www.example.com → example.com` |
| **MX** | 메일 서버 지정 | `mail.example.com (priority=10)` |
| **TXT** | SPF, DKIM 등 인증용 텍스트 정보 | `"v=spf1 include:_spf.example.com"` |

A, CNAME, NS는 HTTP 서비스 운영에서 가장 많이 사용된다.

---

#### 4) DNS 리졸버(Resolver)

Resolver는 OS 또는 ISP가 제공하는 DNS 클라이언트 역할을 한다.

DNS 요청이 발생하면 다음 단계를 수행한다.

1. 브라우저 → OS → Resolver 순으로 DNS 쿼리 전달  
2. Resolver는  
   - Local Cache 확인  
   - 없으면 재귀적으로 Root → TLD → Authoritative 조회  
3. 최종 IP 주소를 클라이언트에게 반환  
4. TTL 동안 응답을 캐싱하여 성능 최적화

Resolver는 실제 DNS 조회의 대부분을 대신 처리한다는 점에서 DNS 동작의 핵심 요소이다.

### 4.1.2 DNS 쿼리

DNS 쿼리는 특정 도메인 이름에 대한 IP 정보 또는 기타 리소스 레코드(A, AAAA, MX 등)를 조회하는 요청이다.  
클라이언트(브라우저 또는 OS)는 DNS 쿼리를 통해 서버와 통신하기 위해 필요한 IP 주소를 얻으며,  
DNS 시스템은 이를 해결하기 위해 *재귀 조회(Recursive Lookup)* 와 *반복 조회(Iterative Lookup)* 를 조합해 동작한다.

DNS 쿼리는 다음 주요 요소로 구성된다.

- **쿼리 이름 (QNAME)**: 조회하려는 도메인 이름  
- **쿼리 타입 (QTYPE)**: 조회하려는 레코드 타입 (예: A, NS, MX 등)  
- **쿼리 클래스 (QCLASS)**: 보통 IN(Internet)  
- **Flags**: 재귀 요청 여부(recursion desired 등)

---

#### DNS 쿼리 흐름 개요

DNS 쿼리는 클라이언트 → 로컬 Resolver → Root → TLD → Authoritative 순서로 처리되며,  
필요한 정보를 찾을 때까지 네임서버들을 단계별로 조회한다.

기본 흐름은 아래와 같다.

1. **브라우저/애플리케이션이 DNS 쿼리 생성**  
2. **OS DNS Resolver로 전달**  
3. **Local DNS Cache 확인**  
   - `/etc/hosts`, 브라우저 캐시, 시스템 캐시 등  
4. **Resolver가 재귀적으로 DNS 서버들에게 질의 수행**  
   - Root → TLD → Authoritative 순으로 조회  
5. **Authoritative 서버에서 최종 레코드 값을 반환**  
6. **Resolver는 TTL 동안 결과를 캐싱하고 클라이언트에게 응답**

---

#### 재귀 쿼리 (Recursive Query)

재귀 쿼리는 클라이언트가 Resolver에게 "최종 결과(IP 주소)를 직접 가져오라"라고 요청하는 방식이다.

특징:

- 클라이언트는 단 1번만 요청  
- Resolver가 여러 DNS 서버와 통신하여 IP를 찾음  
- 현실 세계의 대부분의 DNS 조회 방식  
- 캐싱을 통해 성능이 크게 향상됨

흐름:
```
Client → Resolver
Resolver → Root → TLD → Authoritative
Resolver ← Authoritative(IP 응답)
Client ← Resolver(IP 응답)
```

예:  
브라우저가 8.8.8.8(Google DNS)에게 쿼리하면 8.8.8.8이 전체 과정을 대신 수행해준다.

#### 반복 쿼리 (Iterative Query)

반복 쿼리는 네임서버 간 조회에서 사용되는 방식으로,  
각 서버는 "최종 답"이 아닌 "다음에 조회할 서버 정보"만 응답한다.

특징:

- Root → TLD → Authoritative 간의 서버-서버 통신 방식  
- 각 단계에서 "다음 DNS 서버 위치"만 반환  
- 최종 답변은 Authoritative 서버에 도달해야 얻을 수 있음

예시 흐름:
```
Resolver → Root: “example.com의 A 레코드?”
Root → Resolver: “.com TLD 서버로 가라”

Resolver → .com TLD: “example.com의 A 레코드?”
TLD → Resolver: “ns1.example.com(Authoritative)로 가라”

Resolver → ns1.example.com
ns1.example.com → Resolver: “93.184.216.34”
```

#### DNS 쿼리 예시: 사용자가 `https://game.daum.net/` 에 접속하는 실제 흐름

사용자가 브라우저 주소창에 `https://game.daum.net` 을 입력했다고 가정한다.  
이때 수행되는 DNS Lookup 절차는 다음 순서로 진행된다.

---

##### 1) Client → Resolver  
브라우저 또는 OS는 Local Cache(`/etc/hosts`, system DNS cache, browser DNS cache`)를 먼저 확인한다.  

캐시가 없다면 Resolver(예: 8.8.8.8 또는 ISP DNS)로 다음 쿼리를 보낸다.

```
QNAME: game.daum.net
QTYPE: A (IPv4 주소 조회)
```

---

##### 2) Resolver → Root Server  
Resolver는 Root DNS 서버에 반복(Iterative) 질의를 보낸다.

```
“game.daum.net의 정보를 어디서 얻을 수 있습니까?”
```

**Root Server 응답**:
```
“.net TLD 서버에 물어보라”
```

Root는 "최종 IP"는 모르고, 어떤 TLD 서버로 가야 하는지만 알려준다.

---

##### 3) Resolver → .net TLD Server  
Resolver는 `.net`을 관리하는 TLD 서버에게 다시 질의한다.
```
“daum.net 도메인의 Name Server는 어디입니까?”
```

**TLD 서버 응답**:

예: (실제 Daum/Kakao 계열 NS)
```
ns1.daum.net
ns2.daum.net
ns3.daum.net
```

즉, `daum.net`의 권한 DNS(Authoritative DNS)는 Daum의 네임서버이다.

---

##### 4) Resolver → Authoritative DNS (ns1.daum.net)  
이제 Resolver는 실제로 도메인 정보를 알고 있는 권한 네임서버에 질의한다.

```
“game.daum.net의 A 레코드는 무엇입니까?”
```

**Authoritative 서버 응답**(예시):
```
180.70.134.xxx
```

이 IP 주소가 실제로 game.daum.net 서비스가 배포된 서버(또는 CDN, 로드밸런서)이다.

---

##### 5) Resolver → Client  
Resolver는 얻어진 A 레코드를 캐싱(TTL 동안)한 뒤 Client에게 전달한다.

브라우저는 이제 이 IP로 실제 TCP/TLS 연결을 수행할 수 있게 된다.

---

#### DNS 이후의 실제 연결 과정

DNS 조회가 끝났다고 해서 바로 HTML을 받는 것은 아니다.  
브라우저는 반환된 IP(`180.70.134.xxx`)로 아래 절차를 수행한다.

1. **TCP 3-way handshake (SYN → SYN/ACK → ACK)**  
2. **TLS handshake (HTTPS 인증서 교환)**  
3. **HTTP GET / 요청 전송**

예:
```
GET / HTTP/1.1
Host: game.daum.net
```

4. **서버가 HTML/JS/CSS 응답 반환**  
5. 브라우저가 페이지 렌더링

---

#### 추가 설명: 왜 Authoritative가 daum.net 기준인가?

- 요청한 도메인은 `game.daum.net`
- 서브도메인(game)은 `daum.net`의 zone에 속함  
- 따라서 최종 authoritative DNS는 `daum.net`의 NS가 된다

이 구조 덕분에 Kakao/Daum 서비스 전체가 동일한 네임서버 체계를 사용하면서  
각 서비스별(subdomain) DNS만 개별적으로 관리할 수 있다.

#### 정리

https://game.daum.net 요청 흐름
```
	1.	game.daum.net 의 DNS 정보가 캐시에 없으면
	2.	Resolver → Root
	3.	Root → “.net TLD로 이동하라”
	4.	TLD → “daum.net은 ns1/2/3.daum.net이다”
	5.	Resolver → ns1.daum.net: “game.daum.net A?”
	6.	Authoritative → “180.70.134.xxx”
	7.	Resolver 캐싱 후 Client에게 반환
	8.	Client가 IP로 HTTPS 연결 후 페이지 요청
```

### 4.1.3 운영 환경에서 도메인 사용이 표준인 이유

IP를 직접 .env 파일에 넣으면 DNS 쿼리를 생략할 수 있어 초기 연결 속도는 소폭 빨라질 수 있다.  
그럼에도 불구하고 운영(Production) 환경에서는 **항상 도메인 이름을 사용하는 것이 표준 규칙**이다.  
그 핵심 이유는 다음과 같다.

---

#### 1. IP 변경에 대한 유연성

서비스 인프라는 운영 과정에서 다음과 같은 변경이 빈번하다.

- 서버 교체, 인스턴스 재시작
- Auto Scaling으로 인한 동적 IP 할당
- Blue–Green 배포 또는 Canary 배포
- 장애 조치(Failover)로 인한 IP 변경
- CDN, WAF, 로드밸런서 추가

도메인을 사용하면 이러한 변경이 **DNS 레코드만 수정하면 전체 서비스에 즉시 반영**된다.

반면 IP를 직접 쓰면:

- 환경변수 수정
- 코드/컨테이너 재배포
- 모든 서버에 적용 필요  
→ 운영 리스크 증가

따라서 도메인은 인프라 변경을 “어플리케이션 코드나 배포 없이” 적용할 수 있게 하는 가장 중요한 추상화 계층이다.

---

#### 2. 로드밸런싱 및 고가용성(HA) 구현

도메인 → 여러 IP 등록(A 레코드 여러 개) 또는  
도메인 → 로드밸런서(CNAME, ALIAS) 연결을 통해

- 트래픽 분산(Load Balancing)
- 고가용성(Failover)
- 글로벌 라우팅(Route53, Cloud DNS, GeoDNS)

등이 모두 가능해진다.

IP를 직접 넣으면 단일 서버에 강하게 종속되므로 고가용성 구조가 불가능해진다.

---

#### 3. 인프라 구성 요소에 대한 추상화(Abstract Layer)

도메인은 “서비스 이름”이기 때문에 실제 구현이 무엇이든 상관없이 동일하게 접근할 수 있다.

예:
```
api.example.com → AWS ALB → EC2
api.example.com → CloudFront → Lambda
api.example.com → Nginx → Kubernetes
```

애플리케이션은 `api.example.com`만 알고 있으면 되고,  
뒤에서 인프라가 EC2 → Lambda로 바뀌어도 전혀 영향을 받지 않는다.

즉, 도메인은 **서비스와 인프라의 결합도를 낮춰 유지보수를 쉽게 만든다.**

---

#### 4. 네트워크 정책 및 보안 구성에서 필수적인 표준

현대 클라우드/엔터프라이즈 환경에서 대부분의 보안/네트워크 정책은 도메인 기반으로 설계된다.

- HTTPS 인증서(SNI, SSL/TLS)
- CDN(WAF, Bot Defense)
- Zero Trust 네트워크
- API Gateway / Service Mesh
- OAuth Redirect URI

모두 **도메인을 기준으로 동작**하며, IP만으로는 구현이 불가능하거나 매우 어렵다.

운영 환경에서 TLS를 적용하려면 반드시 도메인 이름이 필요하다.


#### 5. DNS 자체는 캐싱 구조로 매우 빠름

“DNS 쿼리 때문에 느릴 것 같아서 IP를 직접 넣는다”는 오해가 있음.  
그러나 실제로는 DNS 조회는 대부분 캐시(Local/OS/Resolver Cache)에서 해결되므로 매우 빠르다.

- 브라우저 DNS 캐시
- OS DNS 캐시
- 로컬 Resolver 캐시(ISP DNS, 8.8.8.8 등)

DNS는 대부분 **수십 μs(마이크로초)** 단위로 해결된다.

성능 때문에 IP를 넣을 이유는 거의 없다.

## 4.2 DNS의 확장성 · 신뢰성 · 일관성

DNS는 인터넷 전체의 이름 해석을 담당하는 분산 시스템으로,  
대규모 트래픽 처리와 장애 대응, 데이터 일관성을 위해 다음 세 가지 특성을 갖도록 설계되어 있다.

---

### 4.2.1 확장성(Scalability)

DNS는 전 세계 수십억 쿼리를 처리해야 하므로 **계층 구조 + 전역 Anycast + 강력한 캐싱**을 기반으로 확장성을 확보한다.

- **계층 구조**: Root → TLD → Authoritative로 부하가 자연스럽게 분산됨  
- **Anycast 기반 분산 서버**: 가장 가까운 서버가 응답하여 글로벌 확장 용이  
- **TTL 기반 캐싱**: 대부분의 요청이 캐시에서 해결되어 실제 DNS 서버 부하 감소

→ 따라서 DNS는 트래픽 증가에도 안정적으로 확장된다.

---

### 4.2.2 신뢰성(Reliability)

DNS는 장애가 나면 인터넷 전반이 영향을 받기 때문에 **다중 서버 구성 + Anycast + 캐싱**으로 높은 신뢰성을 제공한다.

- **다중 NS 레코드**: 하나의 서버가 장애여도 다른 서버가 응답  
- **Anycast 라우팅**: 장애가 발생한 노드가 자동으로 우회됨  
- **캐싱을 통한 장애 완화**: Authoritative 장애 시에도 TTL 동안 서비스 지속 가능

→ DNS는 부분 장애에도 전체 서비스가 중단되지 않도록 설계되어 있다.

---

### 4.2.3 일관성(Consistency)

DNS는 전 세계에 분산된 캐시와 서버를 사용하기 때문에 **즉시 일관성(Strong Consistency)** 대신 **최종적 일관성(Eventual Consistency)** 을 제공한다.

- **TTL 기반 캐싱**: 변경 내용은 TTL 이후 점진적으로 반영  
- **SOA Serial Number**: Primary–Secondary 간 zone 동기화  
- **Authoritative 서버가 출처(Source of Truth)**: 시간이 지나면 모든 캐시가 authoritative 값으로 수렴

→ DNS 변경사항은 전 세계적으로 “시간차를 두고” 일관된 상태로 정렬된다.

