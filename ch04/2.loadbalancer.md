## 4.3 로드 밸런서

로드 밸런서(Load Balancer)는 여러 서버로 트래픽을 분산하여  
시스템의 **안정성, 성능, 확장성**을 확보하기 위한 핵심 인프라 구성 요소이다.  
대량 트래픽을 균등하게 분배하여 단일 서버 과부하를 방지하고, 장애가 발생한 서버를 자동으로 제외시키는 역할을 한다.

### 목차

- [4.3.1 로드 밸런서 위치](#431-로드-밸런서-위치)
- [4.3.2 로드 밸런서의 장점](#432-로드-밸런서의-장점)
- [4.3.3 전역 로드 밸런싱과 로컬 로드 밸런싱](#433-전역-로드-밸런싱과-로컬-로드-밸런싱)
- [4.3.4 DNS와 로드밸런싱](#434-dns와-로드밸런싱)
- [4.3.5 로드 밸런서가 사용하는 알고리즘](#435-로드-밸런서가-사용하는-알고리즘)
- [4.3.6 OSI 각 계층에서 로드 밸런싱](#436-osi-각-계층에서-로드-밸런싱)
- [4.4 애플리케이션 게이트웨이](#44-애플리케이션-게이트웨이-application-gateway)
  - [4.4.1 기능과 역할](#441-애플리케이션-게이트웨이의-기능과-역할)
  - [L7 로드밸런서와의 차이점](#l7-로드밸런서와의-차이점-애플리케이션-게이트웨이가-추가로-제공하는-기능)

---

### 4.3.1 로드 밸런서 위치

로드 밸런서는 시스템 설계에 따라 다양한 위치에 배치될 수 있다.

#### 1) 클라이언트와 웹 서버 사이 (가장 일반적)
```
Client → [Load Balancer] → Web Server Pool
```

#### 2) 웹 서버와 애플리케이션 서버 사이
```
Client → LB → Web Servers → LB → App Servers
```

#### 3) 내부 서비스 간 트래픽 분배 (Service Mesh, Microservice)
```
Service A → LB → Service B (Replica)
```

#### 4) 글로벌 분산 서비스의 프론트 단 (CDN / GSLB)
```
Client → Global Load Balancer → Regional Load Balancer → Data Center
```

최종적으로 로드 밸런서는 **사용자 요청이 서버에 도달하기 직전의 트래픽 관문** 역할을 한다.

---

### 4.3.2 로드 밸런서의 장점

로드 밸런서는 단순한 트래픽 분산 장치를 넘어, 서비스 안정성과 보안, 성능 향상을 위해 필수적으로 사용되는 인프라 구성 요소이다.  
운영 환경에서 특히 중요한 핵심 장점은 다음 세 가지이다.

---

#### 1) 헬스체크(Health Check)를 통한 자동 장애 감지 및 Failover

로드 밸런서는 백엔드 서버들의 상태를 주기적으로 점검(헬스체크)하여 장애 여부를 자동으로 판단한다.

- 정상 서버: 계속 트래픽 전달  
- 비정상 서버: 즉시 서버 풀에서 제외  
- 정상 복구 시 자동 복귀

이를 통해 단일 서버 장애가 발생해도 전체 서비스는 영향을 받지 않으며,  
Failover 과정이 자동으로 처리되므로 운영 안정성이 크게 향상된다.

---

#### 2) TLS 종료(SSL Termination)로 백엔드 서버 부담 감소 및 안정성 향상

TLS(HTTPS) 암호화/복호화는 CPU 리소스를 많이 소모한다.  
로드 밸런서는 이 작업을 앞단에서 수행하여 백엔드 서버가 비용이 큰 TLS 처리를 하지 않도록 만든다.

#### 동작 방식
1. 로드 밸런서가 클라이언트와 **HTTPS 연결을 종료(복호화)**  
2. 백엔드 서버에는 **암호화되지 않은 HTTP 트래픽** 전달  
3. 서버는 애플리케이션 로직 수행에만 집중 가능

#### 이점
- 백엔드 서버의 CPU 부담 감소  
- TLS 인증서 관리가 LB 한 곳으로 집중되어 운영 편의성 증가  
- 연결 재사용(Keep-Alive) 최적화 가능  
- 전체 시스템 안정성 및 응답 속도 개선

---

#### 3) 트래픽 패턴 분석 기반의 효율적인 요청 분배 알고리즘

로드 밸런서는 단순 라운드 로빈뿐 아니라, 실시간 트래픽 패턴과 서버 상태를 고려하여  
가장 효율적인 방식으로 요청을 분배할 수 있다.

예:

- **Least Connections**  
  현재 연결 수가 가장 적은 서버로 분배 → 웹소켓·스트리밍에서 효율적

- **Weighted Scheduling**  
  서버 성능, 자원 사용률(CPU/메모리)에 따른 가중치 기반 분배

- **IP Hash / Session Affinity**  
  특정 사용자가 항상 같은 서버로 연결되도록 유지  
  (로그인 세션 유지 필요 서비스에서 활용)

- **Consistent Hashing**  
  캐싱 서버나 분산 저장소에서 데이터 편중을 줄이며 확장성 향상

이러한 알고리즘 덕분에 트래픽 변동이 큰 서비스에서도 안정적인 응답 성능을 유지할 수 있다.

### 4.3.3 전역 로드 밸런싱과 로컬 로드 밸런싱
로드 밸런싱은 크게 **전역(Global) 로드 밸런싱**과 **로컬(Local) 로드 밸런싱**으로 나눌 수 있다.  
두 방식은 목적과 동작 범위가 다르며, 서로 보완적으로 사용된다.

---

#### 1) 전역 로드 밸런싱(Global Load Balancing, GSLB)

전역 로드 밸런서는 **지리적으로 서로 다른 지역(Region, Data Center)** 간 트래픽을 분산한다.

```
Client → 전역 LB(GSLB) → 지역 LB → 서버
```

#### 활용 사례
- 다중 Region(한국/미국/일본)에 동일 서비스 운영  
- 글로벌 서비스(게임, OTT, SNS)의 사용자 지연(latency) 최적화  
- 자연재해·지역 장애 대비 DR 구성을 위한 Region Failover

---

#### 2) 로컬 로드 밸런싱(Local Load Balancing)

로컬 로드 밸런서는 **하나의 데이터센터 또는 하나의 VPC 내부**에서  
여러 서버(Replica) 사이에 트래픽을 분산한다.

```
Client → (전역 LB) → 로컬 LB → 서버 풀
```

#### 활용 사례
- 여러 웹 서버/애플리케이션 서버/DB 프록시가 존재하는 환경  
- Microservice 구조에서 서비스 간 트래픽 분배  
- Auto Scaling 그룹의 Replica 서버 분산

### 4.3.4 DNS와 로드밸런싱

DNS 기반 로드밸런싱(GSLB)은 전역 트래픽 분산에 유용하지만, 구조적 특성 때문에 다음과 같은 한계를 가진다.

#### 1) DNS 패킷 크기 제한(512바이트)으로 인해 반환 가능한 서버 목록이 제한됨
DNS 프로토콜은 기본적으로 UDP 기반이며, 응답 패킷 크기가 **512바이트로 제한**되어 있다.  
이 때문에 하나의 질의에 대해 너무 많은 IP 주소를 응답으로 포함시키기 어렵다.

- 여러 지역/서버를 모두 응답에 포함할 수 없음  
- 일부 서버 정보만 반환할 수 있어 전역 분산 효율이 떨어질 수 있음  
- (EDNS 확장으로 해결 가능하지만, 전체 환경에서 완벽하게 지원되는 것은 아님)

#### 2) 클라이언트가 반환된 IP 중 임의 선택 → 과부하 Region으로 붙을 가능성
DNS는 여러 개의 IP를 반환해도, 실제로 어떤 서버에 연결할지는 **클라이언트/Resolver가 임의로 결정**한다.

예:
- 한국 유저가 일본 리전으로 연결되는 경우  
- 이미 과부하가 걸린 데이터센터로 우연히 붙는 경우  

즉, DNS는 “IP 제공자”일 뿐, 실시간 부하 상태를 반영해 서버를 선택할 능력이 없다.

#### 3) 클라이언트와 가장 가까운 서버 선택이 어려움
DNS는 네트워크 지형을 실시간으로 인지하지 못하기 때문에  
사용자와 **가장 가까운 Region/서버를 정확히 판단하기 어렵다.**

- Resolver 위치가 클라이언트와 다를 수 있음  
  (클라이언트는 한국, Resolver는 미국 → 잘못된 지역으로 라우팅)
- DNS는 라우팅 정보나 네트워크 혼잡도를 모름  

→ GeoDNS, Anycast 등을 사용하면 개선되지만  
  설정·운영 난이도가 높고 모든 환경에서 일관되게 동작하지는 않는다.

#### 4) 장애 시 복구가 느릴 수 있음(TTL 영향)
DNS는 TTL 기반 캐싱을 사용하므로, 장애가 난 Region의 IP를 DNS Records에서 제거해도:

- TTL이 길면 클라이언트는 **오래된 IP를 계속 사용**
- 장애 Region으로 트래픽이 계속 전송될 가능성 존재
- 전 세계 Resolver의 캐시가 갱신되기까지 시간이 걸림

즉, DNS 기반 Failover는 **즉각적인 전환이 어렵고 지연이 발생**할 수 있다.

### 4.3.5 로드 밸런서가 사용하는 알고리즘

로드 밸런서는 요청을 어떤 서버로 보낼지 결정하기 위해 다양한 스케줄링 알고리즘을 사용한다.  
이 알고리즘은 크게 **정적(Static)** 방식과 **동적(Dynamic)** 방식으로 구분되며,  
세션 지속성을 어떻게 유지하는가에 따라 **Stateful / Stateless** 로드밸런싱 방식이 결정된다.

---

#### 1) 주요 로드밸런싱 알고리즘

##### 1. 라운드 로빈 스케줄링 (Round Robin)
서버 목록을 순서대로 순환하며 요청을 분배하는 가장 단순한 방식.

특징:
- 구성 간단
- 서버 성능이 동일한 환경에서 균등 분배 효과

---

##### 2. 가중치 기반 라운드 로빈 (Weighted Round Robin)
각 서버의 성능(CPU/메모리)에 따라 가중치를 부여해 비율에 맞게 요청을 분배한다.

예:
- 서버 A: 가중치 3  
- 서버 B: 가중치 1  
→ A가 B보다 3배의 요청을 처리

---

##### 3. 최소 연결 알고리즘 (Least Connections)
현재 **활성 연결 수가 가장 적은 서버**로 요청을 전달.

특징:
- 실시간 연결 유지가 중요한 서비스에 적합(WebSocket, 스트리밍 등)
- 동적 방식으로 분류

---

##### 4. 최소 응답 시간 알고리즘 (Least Response Time)
서버의 **응답 시간 + 연결 수**를 종합적으로 고려하여 가장 빠른 서버에 트래픽을 보냄.

특징:
- 부하가 고르지 않은 환경에서 효과적
- 모니터링 필요 → 동적 방식

---

##### 5. 해시 기반 알고리즘 (Hash-based Scheduling)

###### (1) IP 해시 (IP Hash)
클라이언트 IP를 해싱해 **항상 동일한 서버**에 매핑한다.

사용 목적:
- 세션 고정(Session Affinity)  
- 서버 메모리에 세션 저장 시 유용

###### (2) URL 해시 (URL Hash)
동일한 URL 요청이 동일 서버로 향하도록 해싱한다.

사용 목적:
- 정적 리소스 캐싱 서버 분산

###### (3) 일관성 해시(Consistent Hashing)
노드 추가/삭제 시 재배치 영향이 최소화되는 해시 분배 방식.

사용 목적:
- 캐시 서버, 분산 스토리지, 키-Value DB 파티셔닝  
- Hotspot 방지

---

#### 2) 정적 알고리즘 vs 동적 알고리즘

로드밸런서가 **서버 상태를 반영하는지 여부** 기준으로 분류한다.

##### 정적 알고리즘 (Static)
- 서버의 현재 상태(CPU/메모리/연결 수)를 고려하지 않음  
- 단순한 규칙 기반으로 분배  
- 예:
  - 라운드 로빈  
  - 가중 라운드 로빈  
  - IP 해시 / URL 해시 / Consistent Hashing  

장점:
- 구현 단순, 처리 비용 낮음
- 서버 성능이 유사한 환경에서 안정적

단점:
- 특정 서버 과부하를 감지하지 못함

---

##### 동적 알고리즘 (Dynamic)
- 서버의 실시간 상태를 반영하여 분배  
- 예:
  - 최소 연결  
  - 최소 응답 시간  

장점:
- 서버 부하가 고르게 분산됨  
- 과부하 서버를 자동 회피

단점:
- 모니터링 오버헤드 증가  
- 대규모 시스템에서 계산 비용이 커질 수 있음

---

#### 3) Stateful vs Stateless 로드밸런싱

##### Stateful Load Balancing
로드 밸런서가 **클라이언트의 세션 상태를 직접 저장**하여  
같은 서버로 요청을 보내도록 보장한다.

사용 사례:
- 서버 메모리에 세션 저장(Session Sticky)  
- 분산 캐시(Redis) 같은 외부 저장소가 없는 구조

장점:
- 애플리케이션 수정 없이 세션 지속성 확보

단점:
- LB나 서버 장애 시 세션 유실 가능  
- LB 확장(Scale-out)이 어려움 → 병목 가능성

---

##### Stateless Load Balancing
Stateless 방식에서는 **로드 밸런서가 세션 정보를 저장하지 않는다.**  
LB는 어떤 클라이언트가 어떤 서버에 연결되었는지 기억하지 않으며,  
요청이 들어올 때마다 **알고리즘에 따라 독립적으로** 서버를 선택한다.

세션 지속성이 필요하다면:
- 세션 상태는 **외부 저장소(예: Redis, DB)** 에 저장하거나,
- LB가 세션을 저장하는 대신  
  **IP Hash / Consistent Hashing 등 일관된 해싱 알고리즘**을 사용해  
  "동일 입력 → 동일 서버" 규칙으로 세션을 유지한다.

→ 즉, LB는 상태를 들고 있지 않지만  
**일관된 해싱을 통해 Stateful하지 않으면서도 세션 지속성을 구현할 수 있다.**

장점:
- 완전 수평 확장 가능 (LB 자체도 다중화 용이)
- LB 장애 시에도 세션 정보가 외부 저장소에 있으므로 서비스 영향 최소화
- L7 LB, API 서버, 모던 마이크로서비스 아키텍처에서 표준 방식

단점:
- 세션 필요 시 외부 저장소 구축 필요  
- 서버 추가 시 해싱 매핑이 깨질 수 있음 (Consistenct hashing 통해 완화)

### 4.3.6 OSI 각 계층에서 로드 밸런싱

로드밸런싱은 OSI 모델 중 **전송 계층(L4)** 과 **응용 계층(L7)** 에서 가장 중요한 역할을 한다.  
두 계층은 어떤 정보를 기준으로 서버를 선택하는지, 그리고 어떤 장점을 갖는지가 명확히 구분된다.

---

#### L4 로드 밸런싱 (Transport Layer Load Balancing)

L4 로드밸런서는 **TCP/UDP + IP/Port 정보만**으로 트래픽을 분산한다.  
패킷의 내용을 해석하지 않기 때문에 빠르고 오버헤드가 낮다.

##### L4가 사용하는 정보
- Source IP / Destination IP  
- Source Port / Destination Port  
- TCP / UDP 프로토콜 정보  

---

##### L4 로드밸런싱 동작 과정 (Flow)

1. **클라이언트가 LB의 IP:Port로 TCP/UDP 연결 시도**
2. **LB는 패킷 내용을 읽지 않고, L4 알고리즘으로 서버 선택**
- Round Robin  
- Weighted Round Robin  
- Least Connections  
- IP Hash 등

3. **선택된 서버로 동일한 연결(TCP Handshake 포함)을 전달**
```
LB → Server_X: TCP SYN
```

4. **서버가 응답하면 LB를 통해 클라이언트로 반환**
- LB는 NAT/터널링만 수행  
- HTTP Body 처리 없음

5. **이후 모든 패킷은 LB를 거쳐 Server_X로 전달됨**

##### L4 로드밸런싱의 장점

1. **고성능 / 저지연**
- 패킷 내용 분석이 없어서 속도가 가장 빠름  
- CPU 부하 적음 (커널 수준 처리가 가능)

2. **프로토콜 무관**
- HTTP뿐 아니라 WebSocket, gRPC, Game UDP, RTMP 등 모든 TCP/UDP 기반 서비스에 적용 가능

3. **대규모 연결 처리에 적합**
- 게임 서버, 스트리밍, 실시간 채팅 등 장기 연결에서 효과적

4. **간단한 구성으로 안정적 트래픽 분산**
- 부하 분산 자체에 집중한 계층

단점:
- HTTP 라우팅 불가, URL·Header 기반 제어 불가  
- 세션 지속성은 IP Hash 정도의 약한 방식만 제공

#### L7 로드 밸런싱 (Application Layer Load Balancing)

L7 로드밸런서는 **HTTP/HTTPS 요청 내용을 직접 분석**하여  
URL, Header, Cookie 기반으로 지능적 라우팅을 수행한다.

##### L7이 사용하는 정보
- URL Path (/api/users)  
- Host Header (api.example.com)  
- Cookie / Session ID / JWT  
- User-Agent / Accept-Language  
- HTTP Method (GET, POST, PUT…)  
- Content-Type / 일부 Body 정보

##### L7 로드밸런싱 동작 과정 (Flow)

1. **클라이언트가 LB로 HTTP/HTTPS 요청 전송**
```
GET /api/users HTTP/1.1
Host: api.example.com
Cookie: session_id=abc123
```

2. **LB가 요청을 파싱하여 규칙 기반으로 서버 풀 선택**
- URL 기반  
  - `/api/**` → API 서버  
  - `/static/**` → 정적 서버
- Host 기반  
  - `m.example.com` → 모바일 서버  
- Cookie 기반 Sticky Session  
- JWT 기반 사용자 그룹 분리  

3. **선택된 서버로 요청을 다시 만들어 전달**
```
LB → Server_Y: GET /api/users
```

4. **서버 응답을 LB가 받아 클라이언트로 반환**
- 필요 시 LB가 Header/쿠키를 추가하거나 수정  

---

##### L7 로드밸런싱의 장점

1. **정교한 라우팅 가능**
- URL, Header, Cookie, Host 기반 분배  
- 서비스별·도메인별 분리 가능

2. **세션 스티키(Session Affinity) 기능 제공**
- Cookie 기반으로 동일 유저 → 동일 서버 유지 가능  
- Stateful 환경에 적합

3. **TLS 종료(SSL Termination) 가능**
- LB가 HTTPS 복호화 → 서버 CPU 부담 감소  
- 인증/인가 정책을 LB 단계에서 처리 가능

4. **A/B 테스트 및 Canary 배포 지원**
- 트래픽 비율 조절하여 새 버전 테스트 가능

5. **WAF·Rate Limit 등 보안 기능 통합 가능**
- L7은 Application Layer이므로 공격 탐지/제어가 용이

단점:
- 패킷 분석으로 인해 L4보다 느림  
- 구성 복잡도 증가, 비용 증가  
- LB 장애 시 영향 범위 큼 → 반드시 다중화 필요 

## 4.4 애플리케이션 게이트웨이 (Application Gateway)

애플리케이션 게이트웨이는 OSI **7계층(L7)** 에서 동작하는 고급 로드밸런서로,  
단순한 트래픽 분산을 넘어 **보안 · 인증 · 정책 제어 · API 관리**까지 수행하는  
서비스 진입점(Edge Entry Point) 역할을 한다.

즉, L7 로드밸런서가 “요청을 어디로 보낼지”에 집중한다면,  
애플리케이션 게이트웨이는 **“누가, 무엇을, 어떤 조건으로, 어떻게 보낼 수 있는지”** 까지 관리한다.

대표적인 예:  
- Nginx / Envoy  
- Kong / Apigee  
- AWS API Gateway  
- Azure Application Gateway

---

### 4.4.1 애플리케이션 게이트웨이의 기능과 역할

애플리케이션 게이트웨이는 다음과 같은 핵심 기능을 제공하며,  
전통적인 L7 로드밸런서보다 더 광범위한 책임을 가진다.

---

#### 1) 고급 L7 라우팅 (Advanced Application Routing)

애플리케이션 게이트웨이는 HTTP 요청의 모든 요소를 분석하여  
세밀하고 유연한 라우팅 정책을 제공한다.

- URL 경로 기반 라우팅 ( `/api/**`, `/static/**` )  
- Host 기반 라우팅 ( `api.example.com` → API 서버 )  
- Method 기반 (GET/POST에 따라 분리)  
- Cookie 기반 세션 라우팅  
- Custom Header 기반  
- JWT Claims 기반 라우팅  
- Content-Type 기반 라우팅  

→ 단순 분산이 아닌 **의미 기반(Content-aware) 트래픽 제어**가 가능하다.

---

#### 2) TLS 종료(SSL Termination) 및 암호화 정책

- 게이트웨이에서 HTTPS 트래픽을 복호화하여 서버 부하 감소  
- 서버는 HTTP로 통신해 성능 향상  
- 필요 시 LB→서버 구간도 TLS 재암호화(TLS Re-encryption) 가능  
- TLS 버전 정책·Cipher Suite 관리 가능  

→ 보안 구성과 인증서 관리를 **중앙에서 통합**할 수 있다.

---

#### 3) 인증(Authentication) / 인가(Authorization)

특정 API 또는 요청 경로에 대해 **API Gateway 수준에서 인증/인가를 수행**한다.

- OAuth2 / OIDC 인증  
- JWT 토큰 검증  
- API Key 인증  
- SSO(Single Sign-On)  
- Custom 인증 Webhook  

→ 백엔드 서버는 인증 로직 없이 **비즈니스 로직에 집중**할 수 있다.

---

#### 4) Rate Limiting / Throttling

API 호출량 제어 기능을 게이트웨이 단계에서 적용한다.

- 초당 요청 수 제한  
- IP 단위 Rate Limit  
- 사용자/토큰 단위 Throttling  
- 버스트(Burst) 제한  

→ 악의적인 트래픽 또는 과도한 요청으로부터 백엔드를 보호한다.

---

#### 5) WAF(Web Application Firewall) 및 보안 정책

애플리케이션 레벨 공격을 LB에서 차단할 수 있다.

- SQL Injection  
- XSS(Cross-Site Scripting)  
- Path Traversal  
- OWASP Top 10 공격 방어  
- Bot 탐지 및 차단  
- IP/Geo 기반 접근 통제  

→ 서비스 전체의 **보안 관문(Security Gateway)** 역할을 수행한다.

---

#### 6) 응답/요청 최적화 및 캐싱

- 정적 파일 캐싱  
- API 응답 캐싱  
- Gzip/Brotli 압축  
- Keep-Alive 최적화  
- 헤더 재작성(Rewrite) 및 URL Rewrite  

→ 응답 속도 향상 및 서버 부하 감소.

---

#### 7) 모니터링/로깅 및 정책 중앙화

게이트웨이는 전체 API 호출을 관찰하는 최적의 위치에 있어  
다음 기능을 효율적으로 제공한다.

- Request/Response 로그  
- 에러율, 지연(Latency) 모니터링  
- API 사용량 분석 및 대시보드  
- Prometheus / ELK / OpenTelemetry 연동  
- CORS 정책 일원화  
- 공통 보안 헤더(HSTS 등) 통합 관리  

→ 운영 복잡성을 줄이고 유지보수성을 높인다.

### L7 로드밸런서와의 차이점 (애플리케이션 게이트웨이가 추가로 제공하는 기능)

애플리케이션 게이트웨이는 L7 로드밸런서의 라우팅 기능에 더해  
다음과 같은 고급 기능을 추가로 제공한다.

#### 1) 인증 및 인가 기능
- OAuth2 / OIDC 인증 처리
- JWT 검증
- API Key 인증
- SSO(Single Sign-On)

#### 2) 보안 기능 강화
- WAF(Web Application Firewall) 통합  
- SQL Injection, XSS 등 애플리케이션 공격 방어  
- Bot 차단  
- IP/Geo 기반 접근 제어(ACL)

#### 3) API 관리 기능
- Rate Limiting / Throttling  
- API Key 및 Usage Plan 관리  
- 요청/응답 검증(Request Validation)  
- API 버전 / Stage 관리

#### 4) 캐싱 및 최적화 기능
- API 응답 캐싱  
- 헤더/URL Rewriting  
- Gzip/Brotli 압축 및 전달 최적화

#### 5) 관찰성 및 운영 기능
- API 호출량 모니터링  
- 지연/에러율 분석  
- 중앙화된 로깅 및 Trace  
- 정책 관리(보안/인증/트래픽 제어) 일원화
