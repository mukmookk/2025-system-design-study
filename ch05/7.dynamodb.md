# 목차

- [5.7 DynamoDB](#57-dynamodb)
- [5.7.1 고정된 스키마가 없다](#57-1-고정된-스키마가-없다)
- [5.7.2 DynamoDB API 함수 (간략 정리)](#57-2-dynamodb-api-함수-간략-정리)
- [5.7.3 DynamoDB의 데이터 분할](#57-3-dynamodb의-데이터-분할)
  - [수평적 분할](#수평적-분할)
  - [기본 키 유형](#기본-키-유형)
- [5.7.4 DynamoDB에서의 처리율 최적화](#57-4-dynamodb에서의-처리율-최적화)
- [5.7.5 DynamoDB의 높은 가용성](#57-5-dynamodb의-높은-가용성)

# 5.7 DynamoDB

DynamoDB는 AWS에서 제공하는 완전관리형 분산 키-값(NoSQL) 데이터베이스로,  
확장성, 고가용성, 장애 허용성을 시스템 차원에서 기본 제공하는 것이 특징이다.  
앞서 설명한 키-값 저장소 설계 원칙과 분산 시스템 개념들이 실제 서비스에 구현된 사례라 볼 수 있다.

---

## 5.7.1 고정된 스키마가 없다

DynamoDB는 관계형 데이터베이스와 달리 고정된 스키마(schema)를 요구하지 않는다.

- 테이블 단위로 기본 키만 정의
- 각 아이템(Item)은 서로 다른 속성(Attribute) 집합을 가질 수 있음
- 컬럼 추가나 구조 변경 시 스키마 마이그레이션 불필요

이로 인해 빠른 초기 설계와 점진적인 데이터 모델 확장이 가능하지만,  
데이터 구조에 대한 책임은 애플리케이션 계층에 있다.

---

## 5.7.2 DynamoDB API 함수 (간략 정리)

DynamoDB는 단순한 키-값 접근 패턴을 중심으로 API를 제공한다.

- PutItem  
  - 아이템을 삽입하거나 기존 아이템을 덮어씀

- GetItem  
  - 기본 키로 단일 아이템 조회

- UpdateItem  
  - 아이템 일부 속성만 원자적으로 수정

- DeleteItem  
  - 아이템 삭제

- Query  
  - 분할 키 기준 + 정렬 키 조건 조회

- Scan  
  - 테이블 전체 탐색 (비권장, 비용 큼)

API 설계 자체가  
“키 기반 접근”을 강제하도록 구성되어 있다.

---

## 5.7.3 DynamoDB의 데이터 분할

### 수평적 분할

DynamoDB는 테이블 데이터를 여러 파티션으로 나누어 저장한다.

- 각 파티션은 별도의 스토리지와 처리량 보유
- 데이터는 분할 키를 기준으로 파티션에 분산
- 노드 추가 시 자동으로 수평 확장

---

### 기본 키 유형

DynamoDB는 다음 두 가지 기본 키 타입을 제공한다.

#### 분할 키 (Partition Key)

- 단일 속성으로 구성
- 동일 분할 키 값을 가진 아이템은 같은 파티션에 저장
- 파티션 분산 품질에 직접적인 영향

#### 복합 키 (Partition Key + Sort Key)

- 분할 키 + 정렬 키 결합
- 동일 분할 키 내에서 정렬 키로 아이템 정렬
- 범위 조회(Query)에 최적화

분할 키 설계는  
부하 분산과 성능에 가장 큰 영향을 미친다.

---

## 5.7.4 DynamoDB에서의 처리율 최적화

DynamoDB는 예측 불가능한 트래픽 환경에서도  
안정적인 성능을 유지하기 위해 처리율(capacity)을 시스템 차원에서 관리한다.  
이 절에서는 DynamoDB가 처리율을 할당하고, 과부하를 완화하며,  
장기적으로 트래픽 변화에 적응하는 방식을 설명한다.

---

### 처리율 할당 개념

DynamoDB는 테이블 또는 내부 파티션 단위로 처리율을 관리한다.

- RCU (Read Capacity Unit)  
  - 초당 처리 가능한 읽기 처리량의 단위
- WCU (Write Capacity Unit)  
  - 초당 처리 가능한 쓰기 처리량의 단위
- 각 파티션은 자체적으로 사용할 수 있는 최대 처리율 상한을 가짐

처리율은 테이블 전체에 할당되지만,  
실제 요청 처리는 파티션 단위로 이루어지기 때문에  
파티션 간 트래픽 분포가 성능에 직접적인 영향을 미친다.

---

### 버스팅 (Bursting)

DynamoDB는 단기적인 트래픽 급증을 완화하기 위해  
버스팅(bursting)을 지원한다.

- 평소 사용하지 않고 남아 있던 처리율을 임시로 활용
- 갑작스러운 요청 증가에도 즉각적인 오류를 방지
- 짧은 시간 동안만 허용되며, 지속적인 초과 사용은 불가능

버스팅은 트래픽 예측이 어려운 서비스에서  
일시적인 스파이크를 흡수하는 완충 장치 역할을 한다.

---

### 토큰 버킷 시스템

DynamoDB는 내부적으로 토큰 버킷(Token Bucket) 방식으로  
처리율 소비를 관리한다.

- 처리율은 토큰 형태로 누적됨
- 각 요청은 처리량에 비례한 토큰을 소모
- 토큰이 존재하면 요청을 즉시 처리
- 토큰이 부족하면 요청이 지연되거나 제한됨

이 방식은  
짧은 시간의 요청 몰림과 장기적인 처리율 한계를 분리하여 관리할 수 있게 한다.

---

### 적응형 용량 관리

DynamoDB는 고정된 처리율 배분에 의존하지 않고,  
장기적인 트래픽 패턴을 분석하여 자동으로 리소스를 재배치한다.

#### 적응형 용량 관리의 목적

- 특정 파티션에 트래픽이 집중되는 현상 완화
- 핫 파티션(hot partition)으로 인한 처리율 초과 방지
- 전체 테이블의 처리율을 보다 효율적으로 활용

#### 동작 방식

- 파티션별 트래픽을 지속적으로 모니터링
- 상대적으로 높은 요청을 받는 파티션을 식별
- 해당 파티션에 더 많은 처리율을 우선적으로 할당
- 트래픽이 감소하면 재할당된 리소스를 회수

이를 통해 DynamoDB는  
사용자가 직접 파티션 단위 튜닝을 하지 않아도  
점진적으로 균형을 맞춘다.

---

### 글로벌 접근 제어

DynamoDB는 처리율을 단일 지점에서 제어하지 않고,  
파티션 단위로 관리한다.

- 특정 파티션의 과부하가 전체 테이블 성능에 미치는 영향 최소화
- 트래픽 격리를 통해 안정성 확보
- 부분적인 병목이 전체 장애로 확산되는 것을 방지

이러한 구조는 대규모 시스템에서  
부분 실패를 전체 실패로 전파하지 않기 위한 설계이다.

---

### 사용량에 맞춘 분할

데이터 양이나 요청량이 지속적으로 증가하면,  
DynamoDB는 파티션을 자동으로 분할한다.

- 데이터 크기 또는 처리량 기준으로 분할 수행
- 새로운 파티션에 데이터와 부하를 재배치
- 별도의 샤딩 키 관리 없이 확장 가능

이 과정은 사전에 수동 샤딩을 설계해야 했던 전통적인 시스템과 달리,  
운영 부담을 크게 줄여준다.

---

## 5.7.5 DynamoDB의 높은 가용성

DynamoDB는 고가용성을 기본 전제로 설계된 시스템이며,  
읽기와 쓰기 모두에서 장애 상황을 고려한 구조를 갖는다.

---

### 쓰기 가용성

DynamoDB의 쓰기 요청은 다음 흐름으로 처리된다.

- 데이터는 여러 가용 영역(AZ)에 걸쳐 복제 그룹으로 관리
- 쓰기 요청은 먼저 WAL(Write-Ahead Log)에 기록
- 정해진 수의 복제 노드에 기록되면 쓰기 성공으로 판단

이 방식은 노드 또는 AZ 장애 발생 시에도  
데이터 손실 없이 쓰기 요청을 처리할 수 있도록 한다.

---

### 읽기 가용성

읽기 요청은 내부 파티션 구조를 기반으로 처리된다.

- 각 파티션은 리더 노드를 포함한 복제 그룹으로 구성
- 리더 노드 장애 발생 시 자동으로 새로운 리더 선출
- 기본 읽기 모델은 최종 일관성(Eventual Consistency)
- 필요할 경우 강한 일관성 읽기 옵션 제공 (비용 증가)

이를 통해 DynamoDB는  
읽기 성능과 가용성을 우선적으로 확보하면서,  
비즈니스 요구에 따라 일관성 수준을 조절할 수 있도록 설계되어 있다.