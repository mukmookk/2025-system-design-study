# 5.10 그래프 기반 데이터베이스

# 5.10 그래프 기반 데이터베이스

그래프 기반 데이터베이스(Graph DB)는  
**노드(Node), 관계(Relationship / Edge), 속성(Property)** 을 1급 개체로 다루는 데이터베이스이다.  
데이터 간의 **연결성**(관계)을 중심에 두고 설계된 것이 핵심이다.

## 5.10.1 기본 개념

- **노드(Node)**  
  - 사람, 상품, 계정, 게시글 등 “대상”을 표현  
  - 각 노드는 여러 개의 속성(키-값 페어)을 가질 수 있음  
- **관계(Relationship / Edge)**  
  - 두 노드 간의 연결을 표현  
  - 예: `FOLLOW`, `FRIEND`, `PURCHASED`, `LIKES` 등  
  - 관계 자체도 속성을 가질 수 있음(생성일시, 가중치, 신뢰도 등)
- **속성(Property)**  
  - 노드나 관계에 붙는 키-값 정보  
  - 예: `name='Alice'`, `age=29`, `since='2023-01-01'`

## 5.10.2 주요 특징

1. **관계 중심의 모델링**
   - JOIN 위주의 RDBMS와 달리, 관계를 1급 개체로 저장
   - 복잡한 그래프 탐색(친구의 친구, 추천, 경로 찾기)에 유리

2. **스키마 유연성**
   - 노드 타입별로 속성이 조금씩 달라도 큰 문제 없음
   - 점진적인 모델 확장에 적합

3. **고속 그래프 탐색**
   - 그래프 DB는 **인접 리스트(Adjacency) 기반 탐색**에 최적화
   - 특정 노드에서 이웃 노드로 이동하는 연산이 빠름  
     (일명 “Index-free Adjacency” 개념을 사용하는 DB도 존재)

4. **대표적인 활용 사례**
   - 소셜 네트워크(친구 관계, 팔로우 관계)
   - 추천 시스템(유사 사용자, 유사 상품 그래프)
   - 지식 그래프(Knowledge Graph)
   - 네트워크/보안 분석(통신 경로, 공격 경로 분석)


# 5.11 Neo4j 그래프 데이터베이스

Neo4j는 가장 대표적인 **그래프 데이터베이스**로,  
**Property Graph Model**과 **Cypher 쿼리 언어**를 기반으로 한다.

## 5.11.1 Property Graph Model

Neo4j에서 그래프는 다음 요소로 구성된다.

- **노드(Node)**  
  - 레이블(Label)을 가질 수 있음  
  - 예: `:User`, `:Product`, `:Post`  
- **관계(Relationship)**  
  - 방향성을 가진다(→ 또는 ←)  
  - 관계 타입(Type)이 존재 (`:FRIEND`, `:LIKES`, `:BOUGHT`)  
- **속성(Property)**  
  - 노드/관계에 붙는 key-value  
  - 예:  
    - 노드: `{name: "Alice", age: 29}`  
    - 관계: `{since: "2023-01-01", score: 0.9}`  

## 5.11.2 Cypher 쿼리 언어

Neo4j는 **Cypher**라는 선언형 쿼리 언어를 제공한다.

- 그래프 패턴을 직관적으로 표현
- 예: “Alice가 팔로우하는 사용자 찾기”
  ```cypher
  MATCH (a:User {name: "Alice"})-[:FOLLOWS]->(u:User)
  RETURN u;
  ```

- JOIN 대신 패턴 매칭 개념으로 생각할 수 있음

## 5.11.3 Neo4j의 특징

Neo4j는 그래프 데이터베이스의 장점을 실용적인 시스템으로 구현한 대표적인 사례로,  
트랜잭션, 탐색 성능, 확장성 면에서 균형 잡힌 특성을 가진다.

### 1. ACID 트랜잭션 지원

Neo4j는 그래프 데이터베이스임에도 불구하고 ACID 트랜잭션을 지원한다.

- 단일 인스턴스 기준으로 강한 일관성 제공
- 노드 생성, 관계 추가·삭제, 속성 변경이 모두 트랜잭션 단위로 처리
- 트랜잭션 중 오류 발생 시 전체 작업이 롤백됨

이를 통해 그래프 구조 변경이 잦은 시스템에서도  
데이터 정합성을 안정적으로 유지할 수 있다.

---

### 2. Index-free Adjacency

Neo4j의 핵심 성능 특징은 Index-free Adjacency 구조이다.

- 각 노드는 이웃 노드와의 관계를 직접 참조
- 특정 노드에서 관계를 따라 이동할 때 인덱스 조회가 필요 없음
- 관계의 깊이가 깊어져도 탐색 비용이 급격히 증가하지 않음

이 구조 덕분에  
친구의 친구, 추천 경로, 연결 네트워크 탐색과 같은  
그래프 순회 작업에서 매우 높은 성능을 제공한다.

---

### 3. 확장 및 클러스터링

Neo4j는 리더/팔로워 기반의 클러스터 구조를 지원한다.

- 리더(Leader)
  - 쓰기 요청 처리
- 팔로워(Follower)
  - 리더로부터 데이터 복제
  - 읽기 요청 처리 가능

이 구조를 통해:

- 고가용성 확보
- 읽기 스케일아웃(read scale-out) 가능
- 리더 장애 시 자동 리더 선출을 통한 서비스 지속

---

### 4. 검색과 분석의 균형

Neo4j는 단순 조회뿐 아니라  
깊은 관계 탐색과 분석 쿼리를 함께 수행할 수 있다.

- OLTP 성격의 트랜잭션 처리 지원
- 다단계 관계 탐색 기반의 분석 쿼리 수행 가능
- 트랜잭션 처리와 그래프 탐색을 동일한 데이터 모델로 처리

이로 인해 Neo4j는  
실시간 서비스와 관계 분석이 동시에 필요한 도메인에 적합하다.

---

## 5.12 관계형 모델링과 그래프 모델링

관계형 모델링과 그래프 모델링은  
데이터를 표현하고 관계를 다루는 방식에서 근본적인 차이가 있다.

---

## 5.12.1 관계형 모델링 vs 그래프 모델링

예시 도메인: 사용자와 친구 관계

### 관계형 모델링 (RDBMS)

관계형 모델에서는 관계를 테이블과 외래 키로 표현한다.

- 테이블 설계
  - USER(id, name, age, ...)
  - FRIEND(user_id, friend_id, created_at, ...)
- 친구 목록 조회
  - USER와 FRIEND 테이블을 JOIN하여 질의

특징은 다음과 같다.

- 스키마가 명확하고 정규화에 유리
- 데이터 무결성과 트랜잭션 처리에 강점
- 조인 수가 많아질수록 쿼리가 복잡해짐
- 관계의 깊이가 깊어질수록 성능 저하 가능성 증가

---

### 그래프 모델링 (Graph DB)

그래프 모델에서는 관계 자체가 데이터의 중심이다.

- 노드
  - (u:User {id: 1, name: "Alice"})
- 관계
  - (u1:User)-[:FRIEND]->(u2:User)
- 친구 목록 조회
  - 기준 노드에서 FRIEND 관계를 따라 이웃 노드를 탐색

특징은 다음과 같다.

- 관계 탐색이 직관적이고 자연스러움
- 다단계 관계(친구의 친구 등) 탐색에 유리
- 스키마가 유연하여 필드 및 관계 추가 부담이 적음

---

### 모델 선택에 대한 정리

- RDBMS
  - 명확한 스키마
  - 강한 일관성
  - 전통적인 비즈니스 트랜잭션 처리에 적합

- Graph DB
  - 복잡한 관계와 연결성 분석
  - 경로 탐색과 추천 문제에 적합

두 모델은 상호 배타적이기보다는,  
도메인 특성과 쿼리 패턴에 따라 선택 또는 병행 사용되는 것이 일반적이다.

---

## 5.12.2 그래프 모델링 과정

그래프 모델링은 다음 순서로 진행된다.

### 1. 주요 엔티티를 노드로 정의

- 사용자(User)
- 상품(Product)
- 주문(Order)
- 게시글(Post)
- 태그(Tag)

현실 세계의 개체를 노드로 표현한다.

---

### 2. 엔티티 간의 관계를 관계 타입으로 정의

- :FRIEND
- :LIKES
- :BOUGHT
- :MENTIONED

관계는 방향성과 의미를 명확히 갖도록 설계한다.

---

### 3. 노드와 관계에 필요한 속성 추가

- 노드 속성
  - name
  - age
  - createdAt
- 관계 속성
  - since
  - weight
  - score

---

예시:  
사용자가 게시글에 좋아요를 누르고, 게시글에는 태그가 달린다.

- (User)-[:LIKES]->(Post)
- (Post)-[:HAS_TAG]->(Tag)

이와 같이 모델링하면  
새로운 요구사항이 생겨도  
노드와 관계를 추가하는 방식으로 자연스럽게 확장할 수 있다.