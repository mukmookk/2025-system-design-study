## 목차

- [5.4 get 및 put 함수 구현](#54-get-및-put-함수-구현)
  - [5.4.1 기본 전제](#541-기본-전제)
  - [5.4.2 put(key, value) 함수 구현](#542-putkey-value-함수-구현)
  - [5.4.3 get(key) 함수 구현](#543-getkey-함수-구현)
  - [5.4.4 TTL 및 만료 처리 방식](#544-ttl-및-만료-처리-방식)
  - [5.4.5 분산 환경에서의 get 및 put 확장](#545-분산-환경에서의-get-및-put-확장)
  - [5.4.6 장애 및 예외 처리](#546-장애-및-예외-처리)

## 5.4 get 및 put 함수 구현

키-값 저장소(Key-Value Store)의 핵심 연산은 get과 put이다.  
이 두 연산의 구현 방식은 저장소의 성능, 확장성, 그리고 일관성 모델을 결정짓는 기초 요소이다.

본 절에서는 단일 노드 환경을 기준으로 한 기본 구현 원리를 설명하고,
이후 분산 환경으로 확장할 때 고려해야 할 사항을 함께 정리한다.

---

### 5.4.1 기본 전제

단순한 키-값 저장소는 다음과 같은 전제를 가진다.

키는 고유하며 변경되지 않는다
값은 문자열 또는 직렬화된 바이너리 데이터로 저장된다
내부 자료구조는 해시 테이블(Hash Table)을 사용한다
평균적인 get 및 put 연산의 시간 복잡도는 O(1)이다

---

### 5.4.2 put(key, value) 함수 구현

#### 동작 개요

put 함수는 특정 키에 값을 저장하거나,  
이미 동일한 키가 존재하는 경우 해당 값을 갱신한다.

#### 처리 흐름

put 연산은 다음과 같은 순서로 수행된다.

1. 입력된 key에 해시 함수를 적용한다
2. 해시 결과를 기반으로 내부 저장 위치(bucket)를 결정한다
3. 해당 bucket 내에서 동일한 key가 존재하는지 확인한다
4. key가 존재하면 기존 value를 새로운 value로 갱신한다
5. key가 존재하지 않으면 새로운 엔트리를 추가한다
6. TTL이나 생성 시각과 같은 메타데이터가 있다면 함께 저장한다

#### 구현 시 고려 사항

동일 key에 대해 put이 호출될 경우 덮어쓰기 여부를 명확히 정의해야 한다
TTL을 사용하는 경우, 만료 시각(expire time)을 함께 관리해야 한다
저장 가능한 최대 값 크기와 전체 엔트리 수에 따른 메모리 제한 정책이 필요하다
멀티 스레드 환경에서는 동시성 제어가 필요하다
  - bucket 단위 락
  - 원자적 연산(CAS)을 이용한 락 프리 구조 등

---

### 5.4.3 get(key) 함수 구현

#### 동작 개요

get 함수는 주어진 키에 매핑된 값을 조회하여 반환한다.

#### 처리 흐름

get 연산은 다음과 같은 순서로 수행된다.

1. 입력된 key에 해시 함수를 적용한다
2. 해시 결과를 기반으로 저장 위치(bucket)를 결정한다
3. bucket 내부에서 key에 해당하는 엔트리를 탐색한다
4. key가 존재하지 않으면 null을 반환한다
5. key가 존재하지만 TTL이 만료된 경우, 해당 엔트리를 삭제한 후 null을 반환한다
6. 유효한 엔트리일 경우 value를 반환한다

#### 구현 시 고려 사항

만료 여부 확인은 조회 시점에 수행하는 것이 일반적이다
존재하지 않는 키에 대한 반환 값을 일관되게 정의해야 한다
get 연산은 가능한 한 최소한의 연산만 수행하도록 설계해야 한다

---

### 5.4.4 TTL 및 만료 처리 방식

키-값 저장소는 임시 데이터와 단기 데이터 처리가 많기 때문에,
만료 처리 방식은 매우 중요한 설계 요소이다.

#### Lazy Expiration (지연 만료)

get 또는 put 요청이 들어올 때 만료 여부를 확인한다
만료된 경우에만 해당 엔트리를 삭제한다
구현이 단순하고 추가적인 스레드나 스케줄러가 필요 없다
단점으로는 만료된 데이터가 즉시 메모리에서 제거되지 않을 수 있다

#### Active Expiration (능동 만료)

별도의 스케줄러 또는 백그라운드 작업이 주기적으로 만료 키를 탐색한다
만료된 키를 즉시 제거하여 메모리를 회수한다
추가적인 CPU 사용 비용이 발생한다

일반적으로 두 방식을 혼합하여 사용한다.

---

### 5.4.5 분산 환경에서의 get 및 put 확장

단일 노드 기준의 get 및 put 구현을 분산 환경으로 확장할 경우,
다음과 같은 요소를 추가로 고려해야 한다.

#### 키 분산 (Partitioning)

키에 해시 함수를 적용하여 특정 노드에 할당한다
Consistent Hashing을 사용하면 노드 추가 및 제거 시 데이터 이동량을 최소화할 수 있다

#### 복제 (Replication)

put 시 데이터를 여러 노드에 복제하여 가용성을 확보한다
일부 노드 장애 발생 시에도 데이터를 조회할 수 있다

#### 일관성 모델

Strong Consistency는 put 완료 후 모든 get 요청이 최신 값을 반환하도록 보장한다
Eventual Consistency는 일정 시간이 지나면 최신 값으로 수렴하도록 설계한다
읽기 및 쓰기 쿼럼(quorum)을 통해 일관성과 가용성의 균형을 조정할 수 있다

---

### 5.4.6 장애 및 예외 처리

put 연산이 실패했을 경우 재시도 정책을 정의해야 한다
네트워크 분리 상황에서의 동작을 미리 고려해야 한다
부분 실패로 인한 데이터 불일치 허용 범위를 명확히 해야 한다
타임아웃과 재요청 정책을 명시적으로 설계해야 한다
