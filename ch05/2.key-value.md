# 목차

- [키-값 저장소(Key-Value Store)](#키-값-저장소key-value-store)
- [1. 개념 및 특징](#1-개념-및-특징)
  - [1.1 단순한 데이터 모델](#11-단순한-데이터-모델)
  - [1.2 높은 성능](#12-높은-성능)
  - [1.3 수평 확장](#13-수평-확장)
  - [1.4 TTL 및 만료](#14-ttl-및-만료)
- [2. 키-값 저장소 설계](#2-키-값-저장소-설계)
  - [2.1 기본 제공 메서드](#21-기본-제공-메서드)
  - [2.2 실제 활용을 위한 설계 가이드](#22-실제-활용을-위한-설계-가이드)
- [3. 장점](#3-장점)
- [4. 단점](#4-단점)

# 키-값 저장소(Key-Value Store)

키-값 저장소는 하나의 Key에 대응되는 Value를 저장·조회하는 단순한 구조의 저장소이다.
스키마 제약이 없거나 약하며, 매우 빠른 접근 속도와 수평 확장에 특화되어 있다.

---

## 1. 개념 및 특징

### 1.1 단순한 데이터 모델
- Key → Value 구조
- 관계, 조인 개념 없음
- 데이터 구조 정의 책임이 애플리케이션에 있음

### 1.2 높은 성능
- 읽기·쓰기 연산이 단순
- 메모리 기반 시스템의 경우 매우 낮은 지연시간 제공

### 1.3 수평 확장
- 키 해시 기반 샤딩
- 대규모 트래픽 환경에서 확장 용이

### 1.4 TTL 및 만료
- 키 단위 만료(Time To Live) 지원
- 세션, 캐시, 임시 데이터 관리에 적합

---

## 2. 키-값 저장소 설계

### 2.1 기본 제공 메서드

키-값 저장소는 일반적으로 다음과 같은 연산을 제공한다.

- 기본 연산
  - `put(key, value)`
  - `get(key)`
  - `delete(key)`

- 배치 연산
  - `mget(keys)`
  - `mset(key-value pairs)`

- 상태 및 카운터
  - `exists(key)`
  - `incr(key)`, `decr(key)`

- 만료 관리
  - `expire(key, ttl)`
  - `ttl(key)`

- 탐색 (관리 목적)
  - `scan(pattern, limit)`

---

### 2.2 실제 활용을 위한 설계 가이드

#### 2.2.1 키 설계

- 일관된 네이밍 규칙 사용
  - `도메인:리소스:식별자[:속성]`
- 핫 키 방지
  - 트래픽 집중 키 구조 회피
  - 시간 단위 또는 해시 분산 적용
- 샤딩 고려
  - 분산 환경에서 키 분포 균형 유지

#### 2.2.2 값(Value) 설계

- 직렬화 포맷 선택
  - JSON: 가독성 좋으나 크기 큼
  - Binary: 효율적이나 디버깅 어려움
- 값 크기 제한
  - 대용량 데이터 저장 금지
  - 필요 시 외부 스토리지 참조 사용

#### 2.2.3 TTL 및 만료 전략

- 데이터 성격에 맞는 TTL 설정
  - 캐시, 세션, 잠금 등
- Soft TTL과 Hard TTL 구분
- 캐시 전략(Cache-Aside 등)과 함께 고려

#### 2.2.4 데이터 정합성 및 원본 관리

- 대부분의 경우 DB가 Source of Truth
- KV는 캐시 또는 보조 저장소 역할
- 쓰기 정책 선택
  - Cache-Aside
  - Write-Through
  - Write-Behind

#### 2.2.5 운영 및 장애 대응

- 복제 및 장애 조치 구성
- 데이터 유실 허용 범위 정의
- 키 개수, 메모리 사용량, 히트율 모니터링

---

## 3. 장점

- 매우 빠른 응답 속도
- 높은 수평 확장성
- 단순한 인터페이스
- 특정 패턴(캐시, 세션)에 최적

---

## 4. 단점

- 복잡한 질의 불가능
- 데이터 관계 표현 제한
- 정합성 보장이 제한적
- 애플리케이션 설계 책임 증가