# 3.6 블룸 필터 (Bloom Filter)

Bloom Filter는 **공간 효율적인 확률적 멤버십 판단 자료구조**로,
특정 값이 **“있을 수 있음(maybe present)”** 또는  
**“절대 없음(definitely not present)”**인지를 매우 빠르게 판별할 수 있다.

특징:
- False Positive 가능
- False Negative 불가능
- 매우 빠르고 메모리 효율적

---

# 1. Bloom Filter의 목적

대규모 시스템에서 가장 느린 연산 중 하나
> “이 값이 저장소에 존재하는가?”

Bloom Filter는 다음을 보장한다:

- 존재하지 않는 값 → 즉시 판정 (0.xx ms 미만)
- 존재하는 값 → 실제 저장소 조회로 최종 확인

즉, **Negative Lookup 비용을 획기적으로 줄이는 데 사용되는 자료구조**이다.

---

# 2. Bloom Filter의 구성 요소

1) **Bit Array (m 비트)**
- 0으로 초기화된 비트 배열

2) **k개의 Hash Function**
- 입력값을 m비트 중 k개 위치로 매핑

---

# 3. 저장(Insertion) 방식

값 x를 저장할 때:

```
h1(x) → p1
h2(x) → p2
…
hk(x) → pk
```

해당 비트들을 모두 1로 설정한다.

예:
```
h1(apple) = 3
h2(apple) = 7
h3(apple) = 12
```

비트 배열:
```
index:  0 1 2 3 4 5 6 7 8 9 10 11 12
bits:   0 0 0 1 0 0 0 1 0 0 0  0  1
```

---

# 4. 조회(Query) 방식 — 어떻게 "없다"를 확정하는가?

값 y를 조회할 때:
```
h1(y), h2(y), …, hk(y)
```

을 계산한 뒤 해당 비트가 모두 1인지 확인한다.

### **핵심 규칙**

- **k개 중 하나라도 0이면 → y는 절대 삽입된 적 없음**
- **모두 1이면 → 있을 수도 있음 (False Positive 가능)**

예:
```
h1(orange) = 2
h2(orange) = 11
h3(orange) = 15
```

해당 bit가 하나라도 0이면:
```
orange → definitely not present
```

이 구조 때문에 **False Negative는 절대 발생하지 않는다.**

---

# 5. "있을 수 있음"만 확인 가능한 이유

조회 중 k개 비트가 모두 1일 때:

- 진짜 y 때문에 1인 것인지
- 다른 값들의 해시가 우연히 해당 비트를 1로 만들었는지

구분할 수 없다.

즉:
```
모두 1일 때 → “있을 수도 있음”
하나라도 0일 때 → “절대 없음”
```

이 구조적 특성으로 인해 False Positive가 존재한다.

---

# 6. 장점

- 매우 작은 메모리로 수억 개 키 관리 가능
- 매우 빠른 O(k) 조회
- 분산 저장소의 불필요한 디스크 조회 제거
- 네트워크 호출 감소

---

# 7. 단점

- 삭제 불가능(기본 Bloom Filter)
- False Positive 존재
- 메모리 크기(m), 해시 개수(k) 튜닝 필요

---

# 8. 주요 사용 사례

**(1) 분산 키-값 저장소 (Cassandra / HBase / Bigtable)**
SSTable에 키가 있는지 Bloom Filter로 먼저 판단 →  
없으면 디스크 I/O 없이 바로 실패 반환.

**(2) Redis / Memcached 캐시 레이어**
Cache miss를 줄이기 위한 프론트 필터링.

**(3) 스팸 필터링, 로그 중복 제거**

----

# 9. Redis 예시

Redis에서는 보통 **RedisBloom 모듈**을 사용해 Bloom Filter를 구현한다.  
(공식 모듈: RedisBloom, 커맨드: `BF.RESERVE`, `BF.ADD`, `BF.EXISTS` 등)

Bloom Filter는 “정말 없는 값”을 빠르게 걸러주기 때문에,  
Redis에서는 주로 **DB 접근 줄이기 / 중복 요청 방지 / 크롤링 중복 제거** 용도로 많이 쓰인다.

---

## "추천에서 제외해야 할 아이템" 빠르게 걸러내기 (Bloom Filter 활용)

### 시나리오

- 구성:
  - 사용자 → 추천 엔진
  - 추천 엔진 → Redis/DB 기반의 사용자 히스토리 확인
- 사용자별로 관리해야 하는 항목:
  - 이미 본 콘텐츠
  - 이미 구매/소장한 상품
  - 추천에서 제외해야 할 리소스 목록

문제:
- 사용자가 이미 본 아이템인지 확인하기 위해  
  매번 Redis Set, Sorted Set, 또는 DB를 조회하면 부하가 매우 크다.
- 특히 사용자 수가 많고, 제외해야 할 아이템 리스트가 큰 경우 DB I/O가 병목 지점이 된다.

---

## Bloom Filter를 추가한 구조

1. 추천 엔진이 아이템 후보군을 만들면  
   사용자 전용 Bloom Filter에 먼저 조회한다:  
   `BF.EXISTS user_seen_bf {userId}:{itemId}`

2. `BF.EXISTS` 결과 해석:
   - **0** → "이 사용자는 이 아이템을 본 적 없음"  
     → 추천 후보로 사용
   - **1** → "본 적 있을 수도 있음"  
     → 추천에서 제외(또는 Redis/DB에서 정확한 조회 진행)

Bloom Filter는 존재하지 않는 값에 대한 검증이 빠르고(0이면 100% 없음),  
대규모 사용자 히스토리 체크 비용을 크게 줄인다.

---

## 흐름 요약

1. 추천 엔진이 사용자에 대한 후보 아이템을 생성  
2. 각 아이템에 대해 Bloom Filter 조회  

```
   BF.EXISTS user_seen_bf {userId}:{itemId}
```

3.	결과:
- 0 → 추천 후보 유지
- 1 → 후보 제거 또는 추가 검증
4.	최종 추천 리스트 구성
