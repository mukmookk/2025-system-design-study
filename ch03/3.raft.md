# **3.2.2 Raft 알고리즘**

Raft는 여러 서버(노드)가 **서로 같은 결정을 내리도록 만드는 알고리즘**이다.  
즉, 장애가 나도 모든 서버가 **동일한 순서로 동일한 명령을 처리하게** 해주는 기술이다.

---

# **2. Raft의 핵심 구조**

> Raft 알고리즘의 시작은 leader

## **1) Leader 하나가 모든 쓰기 요청을 책임진다**

Raft의 가장 단순하지만 강력한 개념은 이것이다:

> “모든 변경(Write)은 반드시 Leader 한 명을 통해서만 발생한다.”

Leader가 모든 요청을 **직렬화(순서화)** 하기 때문에 충돌이 발생하지 않는다.

나머지 서버(Follower)는 Leader의 로그를 그대로 복제만 한다.

---

## **2) 과반수(Majority)가 OK 해야 확정된다**

Raft는 항상 **과반수 노드(Majority)** 가 성공해야 commit이 된다.

- 5대 클러스터 → 3대 이상 OK이면 확정  
- 3대만 살아 있어도 계속 진행 가능  
- split brain(잘못된 두 개의 Leader)을 방지

---

## **Term이란 무엇인가?**

Term은 라운드 번호, 회차 번호라고 보면 된다.

```
Term 1 → Term 2 → Term 3 → …
```

Raft에서는 시간이 흐르면서 **여러 Leader가 등장할 수 있다.**  
이때 Term이 없다면 “누가 진짜 리더인지” 구분할 방법이 없다.

Term의 쓰임새는 크게 3가지다.

---

## **(1) 최신 Leader 판별**

더 큰 Term을 가진 노드가 더 최신 Leader 후보이다.  
이전 Term의 Leader가 네트워크 장애로 늦게 돌아오면?

- AppendEntries(term=8) 메시지를 받는 순간  
- 자신은 term=5였던 옛 Leader → 즉시 Follower로 강등됨

Term 덕분에 **오래된 Leader가 리더라고 우기지 않는다.**
---

### **2) Term은 로그 충돌을 정리하는 기준이 된다**

Raft에서 로그는 이렇게 생겼다:

```
Index: 1   2   3   4
Term:  4   4   5   7
```

Term은 “이 로그가 어느 Leader 시대에 생성되었는가”를 나타낸다.

비교 규칙은 단순하다:

1. Term이 큰 로그가 최신  
2. Term이 같다면 Index 큰 로그가 최신

즉, Term이 있으면 로그 충돌을 쉽게 해결할 수 있다.

---

### **3) Term은 선출 과정 중 충돌을 막는다**

Leader 선출 중 여러 노드가 동시에 Candidate가 될 수 있는데,  
Term이 있으면 다음처럼 자연스럽게 해결된다:

- 더 큰 Term을 가진 후보가 자동으로 우선권을 가짐  
- 다른 후보들은 더 큰 Term의 Heartbeat을 받으면 Follower로 즉시 내려감

즉, Term은 선거 혼란을 막는 **우회전 깜빡이 같은 신호등 역할**을 한다.

---

# **4. Raft의 전체 알고리즘(Flow)**

## **1) 선거 (Leader Election)**

### 흐름
1. Follower는 Leader로부터 Heartbeat(AppendEntries)를 계속 받아야 한다.
2. 일정 시간 동안 Heartbeat이 안 오면  
   → Follower → Candidate로 승격
3. Candidate는 Vote 요청(RequestVote)을 모든 노드에 보냄
4. 과반수 득표 → Leader 당선
5. Leader가 Heartbeat을 보내며 지위를 유지한다

### 왜 랜덤 타이머를 사용할까?
모든 노드가 동시에 Candidate가 되면 충돌하므로  
랜덤 타임아웃을 두어 충돌을 줄인다.

## **2) 로그 복제 (Log Replication)**

Leader가 된 노드는 다음 순서로 명령을 처리한다:

1. 클라이언트 → Leader에게 요청 전달
2. Leader는 새로운 로그 엔트리 생성  
   (예: `log[index=7, term=5, command="set x=10"]`)
3. AppendEntries RPC를 follower들에게 전송
4. Followers가 성공 응답을 보내면
5. 과반수 성공 시 Leader는 CommitIndex 증가
6. Leader와 Followers는 Commit된 로그를 상태 머신에 반영

이 구조 덕분에 **모든 노드가 동일한 순서로 로그를 실행한다.**

## **3) 안전성(Safety)**

Split Brain이 발생하지 않는 이유 2가지

---

#### 1)  Log Matching Property  
> "앞부분이 같으면 뒷부분도 절대 안 달라진다"

### 예시

두 노드가 이렇게 같은 로그를 갖고 있다고 하자:

노드 A:
```
index 1  2  3
term  4  4  5
```

노드 B:
```
index 1  2  3
term  4  4  5
```

이 상태라면 이후 로그는 **무조건** 이렇게 동일하게 가야 한다:

- Leader만 로그를 추가할 수 있고  
- Followers는 Leader에게 강제로 맞춰지기 때문

즉:

> Commit된 과거(index ≤ 3)는 절대 “갈라진 버전”이 생기지 않는다.

---

### 2) Leader Completeness Property  
>  "새 Leader는 Commit된 로그를 100% 갖고 있어야 한다"

**예시**

### 1) Commit이 일어날 때:
로그 #10이 Commit되려면:

- Followers 3대 이상(과반수)이 “OK”를 보내야 한다  
→ 즉, 최소 3대는 #10을 가지고 있음

### 2) 새 Leader가 뽑힐 때:
Leader가 되려면:

- 역시 과반수(3표 이상)의 투표를 받아야 함

즉, 투표권을 가진 3대는 모두 **Commit된 #10**을 이미 가지고 있다.  
그들에게 표를 받은 후보 역시 **#10을 가지고 있어야 한다.**

로그가 뒤쳐진 후보는 표를 못 받기 때문에 Leader가 될 수 없다.

그래서:

> Commit된 로그(#10)는 새 Leader에게도 반드시 존재한다.  
> → 절대 사라지지 않는다.

----

# **5. Leader 장애 시 처리**

Leader가 장애가 나면:

1. Followers는 Heartbeat을 못 받고  
2. 타임아웃이 지나면 Candidate로 승격  
3. Term 증가  
4. 선거 재개  
5. 가장 최신 로그를 가진 Candidate가 Leader가 됨

즉:

> 장애가 나도 자연스럽게 새로운 Leader가 등장해 시스템이 계속 동작한다.

---

# **6. 스냅샷과 로그 압축**

Follower가 오래 뒤쳐지면 과거 로그가 매우 많아질 수 있으므로  
Raft는 주기적으로 **스냅샷(snapshot)** 을 만든다.

- 스냅샷: 특정 시점의 전체 상태
- 스냅샷 이후의 로그만 유지
- 뒤쳐진 Follower는 스냅샷 + 이후 로그로 동기화할 수 있음