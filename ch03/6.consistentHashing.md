# **3.5 일관된 해싱(Consistent Hashing)**

일관된 해싱(Consistent Hashing)은  
분산 시스템에서 **노드 추가·삭제 시 데이터 재배치량을 최소화**하도록 설계된 해싱 기법이다.

일반 해싱(mod 기반)과 달리,  
노드가 늘거나 줄어도 **전체 데이터 중 극히 일부만 재할당**되도록 만든다.

---

# **1. 왜 일관된 해싱이 필요한가?**

기본 해싱 방식:
```
node = hash(key) % N
```

문제점:

- N(노드 개수)가 변경되면 대부분 key의 해시 결과가 변경됨
- → 대부분의 데이터를 다른 노드로 옮겨야 함
- → 확장성(Scalability) 부족, 재배치 비용 폭증

따라서 분산 시스템은 **노드 증감 시에도 안정적인 key → node 매핑**이 필요했고,  
이를 해결한 것이 Consistent Hashing이다.

---

# **2. 일관된 해싱의 핵심 아이디어**

### **1) 해시 링(Hash Ring)**  
- 0 ~ 2³² 범위를 원형으로 구성한 "논리적 링"
- Key와 노드 모두 같은 해시 함수를 통해 이 링 위에 매핑됨

```
hash(node) = 노드가 놓일 위치
hash(key) = key가 놓일 위치
```

### **2) Key → 노드 매핑 규칙**
- key는 링에서 **자기보다 시계 방향으로 가장 가까운 노드**에 저장됨  
- 이를 “Successor Node”라고 한다

### **3) 노드가 추가/삭제될 때 일어나는 변화**
- 노드 추가: 새 노드가 담당하는 key 범위만 옮긴다
- 노드 삭제: 그 노드가 맡던 key만 다음 노드가 가져간다

즉, "전체 데이터 재배치량이 O(1/N)" 수준으로 떨어진다.

---

# **3. Virtual Node(가상 노드)로 Hot-spot 해결**

일관된 해싱의 단점:

- 노드를 해시로 배치하면 **균등하지 않은 범위**가 생긴다  
  → 특정 노드에 key가 몰리는 **Hot spot** 발생 가능

해결책:

### 노드를 여러 개의 "가상 노드"로 분해하여 링에 분산 배치

예: node A에 대해

```
A#1, A#2, A#3 … A#100
```

# **3. Ring에 새로운 파티션(P3)이 삽입되었을 때 일어나는 변화**

새 파티션이 Ring에 추가되면  
**P3의 해시 값 위치 기준으로 “그 구간에 속하던 Key들만” 이동하게 된다.**

예시:

기존 Ring 구간:
- P1(900) → P2(3000)

새 Ring 구간:
- P1(900) → **P3(1600)** → P2(3000)

즉, 아래 Key 들만 대상이 된다:

- hash(playerX) ∈ [900, 1600)

예:
- hash("player998") = 1200  
- hash("player412") = 1300  

이 Key들만 P1 → P3로 이동한다.

**그 외 Key들의 파티션은 절대로 바뀌지 않는다.**

# 4. 가상 노드 추가

예: node A에 대해

```
A#1, A#2, A#3 … A#100
```

이제 실제로 Virtual Node가 어떤 문제를 해결하고, 어떻게 동작하는지 자세히 설명한다.

---

## 1) 왜 가상 노드가 필요한가?

### 문제: 노드를 하나만 링에 올리면 **해시 편향(불균형)**이 발생한다  
해시 함수가 아무리 균등하다고 해도,  
노드를 3개·4개처럼 소수만 둘 경우 **각 노드가 담당하는 구간 길이가 크게 차이날 수 있다.**

예:
```
Node A → 위치 10
Node B → 위치 130
Node C → 위치 132
```

링에서 보면:

- A → 10~130까지 **긴 구간** 담당  
- B, C는 130~132, 132~10까지 **짧은 구간** 담당

이때 대부분의 key가 A 구간 안에 들어간다.  
→ **노드 A에 트래픽 집중 (Hot-spot)**  
→ 노드 1대만 과부하 · 장애 위험 증가

---

## 2) 해결책: Virtual Node가 링 전체에 여러 번 배치되도록 한다

노드 A를 하나의 점이 아니라 **100개의 점으로 쪼개** 다음과 같이 배치한다:
```
hash(A + “vnode1”) → 10
hash(A + “vnode2”) → 9000
hash(A + “vnode3”) → 203000
…
hash(A + “vnode100”) → 4,294,000,000
```

이렇게 하면:

- A의 영향력이 링 전체에 고르게 퍼짐  
- A, B, C 각 노드가 **대부분 비슷한 수의 구간**을 담당하게 됨  
- Key 분배가 엄청나게 균등해짐

→ Hot-spot 완화  
→ 특정 노드가 비정상적으로 많은 key를 담당하는 문제 해결됨

---

## 3) Virtual Node 기반 key 라우팅 (동작 방식)

### Step 1. Key를 해싱하여 링에 위치시킨다.

```
pos = hash(key)
```

### Step 2. Virtual Node들 중 “pos 이후로 가장 가까운 vnode”를 찾는다.
예:

```
key = “user123”
hash(user123) = 120
```

링에 다음 vnode가 있다고 하자:

```
A#3 → 12
B#2 → 75
C#8 → 118
A#17 → 150
```

hash(user123)=120 이므로  
120 이후 가장 가까운 vnode는 **A#17 (150)**

### Step 3. A#17이 속한 **물리 노드(A)**가 key를 담당한다

# **5. 일관된 해싱을 사용하는 대표적인 시스템**

### **Amazon Dynamo**
- 일관된 해싱의 대표 구현체
- 각 노드를 수백 개의 Virtual Node로 구성하여 균등 분산
- Dynamo 스타일 DB의 근간이 되는 설계

### **Cassandra**
- Partition key → Token → Hash Ring 구조
- vNode 구조(기본 256개)를 통해 균등한 shard 분배
- 노드 증설 시 자동으로 Token 범위 reassignment

### **Redis Cluster**
- slot(0~16383) 구조 사용  
- 엄밀한 의미의 Consistent Hash는 아니지만  
  **슬롯 이동량을 최소화하는 일관성 있는 Sharding 구조**  
- Cluster 확장 시 일부 Slot만 재할당됨

### **CDN(Cloudflare, Akamai, Fastly)**  
- Edge 서버 선택 시 Consistent Hashing 사용  
- 특정 사용자를 항상 동일한 Edge로 보내기 위함

---

# **6. 장점과 단점**

## ✔ 장점
- 노드 추가/삭제 시 작은 범위만 이동  
- 수평 확장(Horizontal Scaling)에 최적  
- 가상 노드로 고른 데이터 분배 가능  
- 재배치 비용이 적어 장애 시 복구 빠름

## ✔ 단점
- 구현 복잡도 증가  
- 링 데이터 구조 유지 필요  
- 해시 함수 선택, 가상 노드 개수 tuning 필요  