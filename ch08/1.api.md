# API 설계 (스터디용 상세)

분산 시스템에서 API는 서비스 간의 “계약(Contract)”이자 시스템 구조 자체다.  
API 설계 품질은 단순히 호출 성공/실패를 넘어 다음을 좌우한다.

- **확장성**: 트래픽 증가 시 수평 확장과 캐시, 게이트웨이 적용이 쉬운가?
- **유지보수성**: 변경이 생겼을 때 영향을 예측하고 통제할 수 있는가?
- **장애 대응**: 에러 원인을 빠르게 파악하고, 재시도/중복/타임아웃을 안전하게 처리할 수 있는가?
- **보안/거버넌스**: 인증/인가/감사/속도 제한을 일관되게 적용할 수 있는가?

이 문서는 REST와 gRPC를 “정답/오답”이 아니라 **목적에 맞는 도구 선택** 관점에서 정리한다.

---

## 8.1 REST API

REST(Representational State Transfer)는 HTTP 기반의 자원(Resource) 중심 설계 스타일이다.  
외부 공개 API, 웹/모바일 클라이언트, 파트너 연동 등 “범용성”이 중요한 환경에서 표준처럼 사용된다.

---

### 8.1.1 REST 설계 원칙 (세부)

#### 1) 자원(Resource) 중심 URI

**핵심**
- URI는 **자원(명사)** 을 표현한다.
- 행위(동사)는 **HTTP 메서드**가 표현한다.

**좋은 URI의 특징**
- 자원을 식별 가능: `/users/{userId}`
- 계층 관계가 자연스럽다: `/orders/{orderId}/items`
- 일관된 복수형 사용: `/users`, `/orders`

**예시**
- 사용자 생성: `POST /users`
- 사용자 조회: `GET /users/{id}`
- 사용자 수정: `PATCH /users/{id}`
- 사용자 삭제: `DELETE /users/{id}`

**안티 패턴**
- 동사 중심 URI
  - e.g.  `/createUser`, `/deleteUser`
- 과도한 깊이(조인 덩어리처럼)
  - e.g. `/users/{id}/orders/{orderId}/items/{itemId}/...`
  - 필요한 경우 **관련 자원을 별도 엔드포인트로 분리**하는 것이 운영/확장에 유리

**도메인 액션(“자원인데 행위처럼 보이는 것”) 처리**
- “결제 승인”, “주문 취소” 같은 것은 자원 업데이트로 표현하기 어렵다.
- 이 경우 보통 아래 중 하나를 선택한다.

1) 상태 전이로 표현(권장)
- `PATCH /orders/{id}` body: `{ "status": "CANCELLED" }`

2) 서브 리소스로 표현
- `POST /orders/{id}/cancellations`

3) 명시적 액션 엔드포인트(최후)
- `POST /orders/{id}:cancel` (일부 API 스타일)

---

#### 2) HTTP 메서드 의미 준수 (멱등성/안전성 포함)

| 메서드 | 의미 | 안전(Safe) | 멱등(Idempotent) | 비고 |
|---|---|---:|---:|---|
| GET | 조회 | O | O | 서버 상태 변경 금지 |
| POST | 생성/처리 | X | X | 중복 요청 시 중복 생성 위험 |
| PUT | 전체 교체 | X | O | 동일 요청 반복해도 최종 상태 동일 |
| PATCH | 부분 변경 | X | △ | 설계에 따라 멱등 가능 |
| DELETE | 삭제 | X | O | 이미 삭제된 자원을 또 삭제해도 결과 동일 |

**멱등성 설계가 중요한 이유**
- 네트워크는 실패한다.
- 타임아웃이 발생하면 클라이언트는 “요청이 서버에 도착했는지” 모른다.
- 따라서 클라이언트 재시도는 흔하고, 서버는 이를 고려해야 한다.

**POST 멱등성 보강(실무 핵심)**
- 결제/주문 생성 등 “중복이 치명적”인 POST는 아래를 도입한다.
  - **Idempotency Key**(헤더/필드로 전달)
  - 서버는 동일 key로 들어온 요청의 결과를 캐시/저장하고 동일 응답 반환

예)
- `POST /payments`
- Header: `Idempotency-Key: <uuid>`
- 같은 Key로 재시도 → 동일 결제 요청을 중복 생성하지 않음

---

#### 3) 상태 코드(Status Code) 표준화 (의미를 “일관되게”)

**왜 중요?**
- 클라이언트는 상태 코드를 기준으로 재시도, 사용자 메시지, UI 흐름을 결정한다.
- 상태 코드가 뒤죽박죽이면 장애/오류 처리 로직이 무너진다.

**자주 쓰는 성공 코드**
- `200 OK`: 조회/수정 성공 + 응답 본문 존재
- `201 Created`: 생성 성공 + `Location` 헤더로 생성된 리소스 위치 제공 가능
- `204 No Content`: 성공 + 응답 본문 없음(삭제, 일부 업데이트 등)

**자주 쓰는 실패 코드**
- `400 Bad Request`: 요청 형식/유효성 오류(필수값 누락, 타입 오류 등)
- `401 Unauthorized`: 인증 실패(토큰 없음/만료/검증 실패)
- `403 Forbidden`: 인증은 됐지만 권한 없음
- `404 Not Found`: 리소스 없음
- `409 Conflict`: 중복 생성, 상태 충돌(예: 이미 결제 완료된 주문 취소)
- `422 Unprocessable Entity`: 형식은 맞지만 도메인 규칙 위반(팀 컨벤션에 따라 400/422 선택)
- `429 Too Many Requests`: 속도 제한
- `500 Internal Server Error`: 서버 내부 오류
- `502/503/504`: 게이트웨이/의존성 장애(특히 마이크로서비스에서 흔함)

**에러 응답 표준 포맷(권장)**
- 운영/디버깅을 위해 “머신 친화적”이어야 한다.

예시(JSON)
- `code`: `USER_EMAIL_DUPLICATED`
- `message`: 사람이 읽는 메시지
- `details`: 필드/제약 실패 정보(배열 가능)
- `traceId`: 로그/트레이싱 연계용
- `timestamp`

---

#### 4) 무상태성(Stateless) (스케일 아웃의 전제)

**의미**
- 서버가 세션에 의존하지 않고, 요청 하나만으로 처리 가능해야 한다.
- 인증정보(토큰), 요청 컨텍스트(헤더), 입력 데이터가 매 요청에 포함된다.

**장점**
- 로드밸런서가 어떤 서버로 보내도 된다(세션 스티키 불필요)
- 서버 증설/축소가 쉬움
- 장애 시 다른 서버로 즉시 대체 가능

**주의**
- “완전 무상태”는 불가능한 경우도 있다.
  - 예: 결제 처리 상태, 장바구니 등은 어딘가에 상태가 있어야 한다.
- 핵심은 “서버 메모리에 상태를 두지 말고” **DB/캐시 같은 외부 저장소에 상태를 둬라**는 것이다.

---

#### 5) 버전 관리(Versioning) (변경을 통제하는 기술)

**왜 필요?**
- API는 바뀐다.
- 그러나 클라이언트는 즉시 업데이트되지 않는다.
- 따라서 “변경 비용”을 줄이려면 호환성을 관리해야 한다.

**일반적인 버전 방식**
1) URI 버전(가장 직관적)
- `/v1/users`
- 장점: 명확함, 문서화 쉬움
- 단점: URI가 지저분해질 수 있음

2) Header 버전
- `Accept: application/vnd.company.api.v1+json`
- 장점: URI 깔끔
- 단점: 테스트/디버깅 난이도 증가

**버전 전략 실무 팁**
- 가능하면 “버전 올리기”보다 **하위호환 변경(필드 추가)** 으로 유지
- 제거/이름 변경은 되도록 새 필드 추가 후 기존 필드 deprecate(유예기간)
- 배포/운영 정책: v1 유지 기간, v2 전환 가이드, deprecation 공지

---

### 8.1.2 REST 장단점 (현실적인 관점)

**장점**
- HTTP/JSON 기반으로 어디서든 접근 가능(브라우저/모바일/서버)
- 디버깅이 쉽다(curl, Postman)
- 캐시, 프록시, CDN 등 HTTP 인프라 활용 가능
- 학습 비용이 낮아 조직 확장에 유리

**단점**
- 텍스트(JSON) + 헤더 오버헤드 → 내부 고빈도 통신에서 비효율 가능
- 타입 계약이 약해 “런타임에서 깨지는” 문제가 생기기 쉬움
- 일관되지 않은 에러/상태 코드 사용 시 운영 난이도가 급상승
- 스트리밍은 별도 기술(WebSocket/SSE)이 필요하고 표준이 분산됨

---

## 8.2 gRPC API

gRPC는 HTTP/2 + Protocol Buffers 기반 RPC 프레임워크다.  
“서비스 간 호출”을 **강한 계약(스키마)** 으로 안정화하고, 성능을 높이는 목적에 적합하다.

---

### 8.2.1 gRPC 설계 원칙 (세부)

#### 1) Contract-first (`.proto`) (계약이 곧 API)

- `.proto` 파일이 API의 단일 진실 소스(SSOT) 역할을 한다.
- 서버/클라이언트는 코드 생성으로 동일한 계약을 공유한다.

**장점**
- API 명세와 구현이 어긋날 가능성이 크게 줄어든다.
- 컴파일 타임에 타입 오류를 발견하기 쉽다.

---

#### 2) 강한 타입과 스키마 호환성 (Protobuf의 룰)

gRPC의 안정성은 “스키마 변경 규칙”을 지키는 데서 나온다.

**권장 변경(대체로 안전)**
- 새 필드 추가
- optional 필드 추가
- enum 값 추가(기존 값 의미 변경 금지)

**위험한 변경**
- 필드 번호 재사용
- 필드 타입 변경(특히 숫자/문자 변환)
- 필드 삭제(대신 deprecated 처리 후 무시 권장)

**실무 팁**
- 필드 이름보다 “필드 번호(tag)”가 중요하다.
- 번호는 영구 식별자라고 생각해야 한다.

---

#### 3) 서비스 경계 명확화

- gRPC는 내부 통신이므로 “기능을 빠르게 추가”하기 쉽다.
- 그러나 서비스가 비대해지면 변경 영향이 커지고 배포 리스크가 증가한다.

권장:
- 도메인 기준으로 서비스 분리
- API는 “하나의 책임”을 갖도록 설계

---

#### 4) 호출 방식 선택 (Unary vs Streaming)

gRPC는 스트리밍을 기본으로 지원한다.

- **Unary**: 일반적인 요청/응답
- **Server Streaming**: 서버가 여러 메시지를 순차 전송(예: 실시간 업데이트)
- **Client Streaming**: 클라이언트가 여러 메시지 업로드(예: 파일/로그 업로드)
- **Bidirectional Streaming**: 양방향(예: 채팅, 실시간 상호작용)

**설계 포인트**
- 스트리밍은 성능/실시간성에 강점이 있지만,
  재시도/타임아웃/에러 처리 전략이 더 중요해진다.

---

### 8.2.2 gRPC 장단점 (현실적인 관점)

**장점**
- Protobuf + HTTP/2 → 높은 처리량, 낮은 지연
- 타입 안정성(계약 기반)
- 코드 생성으로 개발 생산성/일관성 ↑
- 스트리밍으로 실시간 데이터 처리에 강함

**단점**
- 브라우저 직접 접근이 어려움(웹 노출은 REST 병행이 흔함)
- 바이너리 포맷이라 디버깅 도구/숙련 필요
- 운영 관측(로그/트레이싱) 설계를 제대로 하지 않으면 문제 파악이 어려움
- 스키마 호환 규칙을 어기면 클라이언트/서버가 쉽게 깨짐

---

## 8.3 REST vs gRPC (선택 기준을 명확히)

| 항목 | REST | gRPC |
|---|---|---|
| 주 대상 | 외부/공개 API, 웹/모바일 | 내부 마이크로서비스 |
| 포맷 | JSON(텍스트) | Protobuf(바이너리) |
| 성능/지연 | 보통 | 우수 |
| 타입 계약 | 약함 | 강함(계약 기반) |
| 스트리밍 | 제한적 | 기본 지원 |
| 디버깅 | 쉽다 | 상대적 어려움 |
| 변화 관리 | 관행/문서 기반 | 스키마 규칙 기반 |

---

### 8.3.1 실무 패턴 (왜 외부 REST + 내부 gRPC가 흔한가)

**외부는 REST**
- 브라우저/모바일/파트너 연동 등 범용 클라이언트 지원
- 문서화/테스트/디버깅이 쉬움
- API Gateway, 인증, 캐시 등 생태계 활용

**내부는 gRPC**
- 고빈도 호출/낮은 지연 요구
- 계약 기반으로 서비스 간 변경 안정성 확보
- 스트리밍/양방향 통신 활용 가능

---

### 8.3.2 설계 결정 체크리스트

- 호출 대상이 외부 사용자/파트너인가? → REST 우선
- 서비스 내부 호출이 많은가? 지연이 중요한가? → gRPC 고려
- 타입 계약이 강하게 필요하고, 자동 코드 생성이 유리한가? → gRPC
- 브라우저 호환/디버깅 편의가 중요한가? → REST
- 실시간 스트리밍이 필요한가? → gRPC(또는 REST+WS/SSE)

---

### 8.3.3 흔한 실수(안티 패턴)

- REST에서 상태 코드를 의미 없이 남발(항상 200 + 에러 body)
- POST 재시도 시 중복 생성 방지(멱등성) 미설계
- REST의 URI가 동사 중심으로 비일관적
- gRPC에서 필드 번호를 재사용하거나 타입 변경
- 내부 통신을 전부 REST로 통일해 성능/계약 문제가 누적
- 반대로 외부 공개 API를 gRPC로만 제공해 접근성이 나빠짐