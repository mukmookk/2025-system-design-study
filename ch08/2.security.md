# 8.4 API 보안

분산 시스템에서 “보안”은 단순히 해킹을 막는 문제만이 아니라,
**서비스를 안정적으로 운영하기 위한 안전장치**다.

- 인증/인가가 약하면 데이터 유출, 권한 오남용, 내부 침투가 발생한다.
- Rate limiting이 없으면 작은 버그나 스파이크 트래픽에도 전체 서비스가 무너질 수 있다.
- 분산 환경에서는 호출자가 다양하고(사용자/서비스/배치), 경로도 복잡하기 때문에
  **표준화된 보안 설계**가 필수다.

---

## 8.4.1 인증(Authentication)

### 1) 인증이란?
인증은 **“이 요청을 보낸 주체(Principal)가 누구인가?”** 를 확인하는 과정이다.  
즉, 신원 확인 단계이며, 이후 인가(권한 판단)의 전제가 된다.

---

### 2) 대표 인증 방식

#### (1) API Key
**개념**
- 클라이언트가 발급받은 키를 요청에 포함시켜 신원을 증명하는 방식
- 보통 헤더(`X-API-Key`) 또는 쿼리 파라미터로 전달

**장점**
- 구현이 쉽고 비용이 낮다
- “파트너 연동”, “단순 서비스 호출” 같은 정적인 클라이언트에 적합

**단점/주의**
- 유출되면 끝(사용자 비밀번호처럼 2차 인증이 어렵다)
- 사용자 단위 권한 표현이 약함(대개 “클라이언트 단위”)
- 키 교체(rotate) 체계를 반드시 만들어야 함

**운영 팁**
- 키는 반드시 서버측에서 해시/암호화 형태로 저장(평문 저장 금지)
- 키별 rate limit, 사용량 모니터링, 폐기 정책 필요

---

#### (2) JWT (JSON Web Token)
**개념**
- 로그인(인증) 결과로 발급되는 **서명된 토큰**
- 서버가 세션을 저장하지 않는 **Stateless 인증**에 적합
- 토큰 내부에 클레임(claim: 사용자ID, 권한, 만료시간 등)을 담는다.

**전형적인 구성 요소**
- Header: 알고리즘(예: RS256)
- Payload: 클레임(iss, sub, exp, aud, roles 등)
- Signature: 위 내용을 서명한 값

**장점**
- 서버 세션 저장 없이도 인증 가능(스케일 아웃 유리)
- 서비스 간 인증 전파에 활용 가능(게이트웨이→내부 서비스)

**단점/주의**
- 토큰이 유출되면 만료 전까지 악용될 수 있음
- “즉시 폐기(로그아웃)”가 어렵다(서버가 상태를 안 들고 있으므로)
- 클레임에 민감정보를 넣으면 위험(토큰은 base64이지 암호가 아님)

**운영 설계 포인트**
- Access Token은 **짧게(예: 5~15분)**, Refresh Token은 더 길게
- Refresh Token은 저장소(Redis/DB)에 저장하고 폐기 가능하도록
- 토큰은 HTTPS(TLS)에서만 전송
- 알고리즘은 HS256(shared secret)보다 RS256(비대칭키) 선호되는 경우가 많음(조직/보안정책에 따라)

---

#### (3) OAuth2 / OIDC
**개념**
- OAuth2: 권한 위임(Authorization) 프레임워크
- OIDC: OAuth2 위에 “인증(Identity)”을 얹은 표준 (ID Token 제공)

**왜 쓰나?**
- 구글/카카오 로그인 같은 SSO 연동
- 기업 내부 SSO/IdP(Okta, Keycloak 등)와 통합
- 외부 파트너에게 “토큰 기반 접근”을 표준으로 제공할 때 유리

**대표 플로우(이해 포인트)**
- Authorization Code Flow: 사용자 로그인 + 권한 동의 → 서버가 코드 받아 토큰 교환
- Client Credentials Flow: 서비스-서비스 통신(사용자 없이)에서 토큰 발급

**장점**
- 표준 기반, 확장 가능, 다양한 인증 제공자와 통합 쉬움
- scope 단위로 권한 모델링 가능

**단점/주의**
- 개념/흐름이 복잡해 학습 비용 존재
- 토큰/리프레시/만료/회수 등 운영 포인트가 많음

---

### 3) 인증 설계 시 고려사항 (중요)

#### 1) 토큰 만료(Expiration)
- Access Token 짧게: 유출 피해 범위를 줄임
- Refresh Token 길게: 사용자 경험(재로그인 최소화)

#### 2) 탈취 대응 전략
- HTTPS 강제
- 토큰 저장 위치 주의(브라우저면 HttpOnly 쿠키 등)
- 탈취 의심 시 토큰 강제 회수(Refresh Token blacklist/rotate)

#### 3) 서비스 간 인증(Internal Auth)
- 마이크로서비스 환경에서는 “사용자”뿐 아니라 “서비스”도 인증 대상이다.
- 방법 예:
  - mTLS(서비스 인증)
  - OAuth2 Client Credentials
  - 내부 네트워크만 믿지 말고, 서비스 호출에도 인증/인가 적용(Zero Trust 관점)

---

## 8.4.2 인가(Authorization)

### 1) 인가란?
인가는 **“인증된 주체가 이 작업을 수행할 권한이 있는가?”** 를 판단하는 과정이다.

- 인증: 너 누구야?
- 인가: 너 이거 해도 돼?

---

### 2) RBAC (Role-Based Access Control)
**개념**
- 역할(Role)에 권한을 부여하고, 사용자에게 역할을 부여하는 방식

예)
- ADMIN: 모든 기능 가능
- OPERATOR: 운영 기능 가능
- USER: 일반 기능만 가능

**장점**
- 이해/관리 쉬움
- 조직 구조(직군/직책)에 잘 맞는다

**단점**
- 역할이 늘어나면 폭발(Role explosion)
- 리소스 단위(“내 리소스만 접근”) 제어는 RBAC만으로 부족할 수 있음

---

### 3) ABAC (Attribute-Based Access Control)
**개념**
- 사용자/리소스/환경 속성(attribute)을 기반으로 정책을 적용

예)
- user.department == resource.department
- user.region == "KR" AND request.time in workingHours
- resource.ownerId == user.id

**장점**
- 매우 유연하고 정교한 정책 가능
- “내 데이터만”, “특정 조건에서만” 같은 제어에 강함

**단점**
- 정책이 복잡해지고 운영 난이도가 올라감
- 정책/속성 관리 체계가 없으면 혼란

---

### 4) 인가 설계 핵심 원칙: 최소 권한(Least Privilege)
- 기본은 deny(거부), 필요한 것만 allow(허용)
- 민감 API는 별도 권한/별도 스코프로 분리
- 운영 권한은 사용 이력 감사(audit)가 가능해야 함

---

## 8.4.4 요청 속도 제한 (Rate Limiting)

### 1) 왜 필요한가?
Rate limiting은 “보안 + 안정성”을 동시에 해결한다.

- 공격 완화: DDoS, 봇, credential stuffing
- 과부하 방지: 버그/루프/재시도 폭주로 인한 장애
- 공정성: 특정 사용자가 자원을 독점하지 않게 함
- 비용 통제: 외부 API 호출 비용, DB 부하 등을 제한

---

### 2) 어디에 적용하는가?
- **Edge 레벨(우선 적용)**: CDN/WAF/API Gateway/Ingress
  - 장점: 애플리케이션까지 트래픽이 도달하기 전에 차단
- **애플리케이션 레벨**: 사용자/기능별 세밀한 정책
  - 장점: “특정 API는 더 엄격”, “유료 사용자 우대” 같은 정책 가능

---

### 3) Rate limiting 키(기준) 선택
무엇을 기준으로 제한할지 정해야 한다.

- 사용자 ID 기준(로그인 사용자)
- API Key 기준(파트너/클라이언트)
- IP 기준(비로그인/공격 탐지)
- 토큰/클라이언트ID 기준(OAuth)
- 엔드포인트 기준(민감 API 별도 제한)

실무에서는 “하나만” 쓰기보다 조합이 흔하다.
- 예) IP + 사용자ID + API별 제한

---

### 4) Rate limit 알고리즘

#### 4.1 토큰 버킷 (Token Bucket) — 버스트 허용
**개념**
- 버킷에 토큰이 최대 용량까지 쌓인다.
- 토큰이 일정 속도로 채워진다(초당 r개).
- 요청 1개당 토큰 1개를 소비한다.
- 토큰이 없으면 요청을 거부(또는 대기).

**직관**
- 평소에 토큰을 “저축”해두었다가,
  갑자기 요청이 몰리면(버스트) 저축분으로 처리 가능

**예시**
- 용량 20, 충전 10/s
- 순간적으로 15개 요청 → 토큰이 20이면 모두 허용
- 다음 1초에 다시 15개 요청 → 토큰이 10만 충전되므로 일부 제한

**장점**
- 사용자 경험이 좋다(짧은 순간 폭주 허용)
- 모바일 앱 초기 동시 호출 등에 적합

**단점**
- 버킷 용량이 너무 크면 공격 트래픽도 크게 허용할 수 있음
- “최대 버스트 허용량”을 신중히 설계해야 함

---

#### 4.2 누수 버킷 (Leaky Bucket) — 일정 처리량 유지
**개념**
- 들어온 요청을 버킷(큐)에 쌓는다.
- 큐에서 일정 속도로만 요청이 빠져나간다(초당 r개).
- 큐가 가득 차면 추가 요청은 드롭/거부한다.

**직관**
- 입력은 들쑥날쑥해도, 출력은 항상 일정하게 유지(평탄화)

**예시**
- 처리 10/s, 큐 20
- 순간 25개 요청 → 10개 처리, 15개 대기
- 이후 초당 10개씩 대기 처리
- 만약 큐가 꽉 찼다면 초과 요청은 거부

**장점**
- 백엔드(특히 DB)를 강력히 보호
- 처리량이 안정적

**단점**
- 큐가 길어지면 응답 지연 증가
- 결국 큐 초과 시 드롭이 발생할 수 있음

---

#### 4.3 슬라이딩 윈도우 (Sliding Window) — 공정하고 정밀
**개념**
- 최근 N초(예: 60초) 동안의 요청 수를 센다.
- 그 수가 제한을 넘으면 차단한다.
- 시간 창이 “고정”이 아니라 계속 이동한다.

**왜 좋은가?**
- 고정 윈도우의 경계 문제를 줄인다.
  - 고정 윈도우는 00:59에 100개, 01:00에 100개를 보내면 1초 사이 200개가 허용될 수 있음
- 슬라이딩 윈도우는 “최근 60초”라서 경계 악용이 어렵다.

**구현 관점(이해 수준)**
- Sliding Log: 모든 요청 타임스탬프 기록(정확하지만 비쌈)
- Sliding Counter: 시간을 작은 버킷으로 나눠 합산(근사지만 효율)

**장점**
- 공정하고 매끄러운 제한
- 공개 API 사용자 제한에 적합

**단점**
- 분산 환경에서는 상태 저장(예: Redis)이 필요하고 구현 비용이 큼

---

### 5) 타임라인 예시 (초당 10개 허용)

가정: 사용자 A가 아래처럼 요청을 보낸다.

| 시간 | 요청 수 |
|---|---:|
| 0초 | 25 |
| 1초 | 5 |
| 2초 | 5 |

#### 토큰 버킷 결과(버스트 흡수)
- 0초: 토큰이 충분하면 25개 중 다수 처리(저축분 사용)
- 이후: 충전 속도에 맞춰 정상화

#### 누수 버킷 결과(처리량 일정)
- 0초: 10개 처리, 나머지는 큐에 적재
- 1초/2초: 초당 10개씩 처리하며 따라잡음(큐가 넘치면 드롭)

#### 슬라이딩 윈도우 결과(정밀 차단)
- 0초: “최근 1초” 기준 10개만 허용, 나머지 차단
- 1초 이후: 윈도우가 이동하며 일부 허용 여지 발생

---

### 6) 선택 가이드 (실전 기준)

| 상황 | 추천 | 이유 |
|---|---|---|
| 모바일 앱/웹이 순간적으로 여러 API 동시 호출 | 토큰 버킷 | 버스트 허용으로 UX 좋음 |
| DB 보호, 내부 파이프라인 보호 | 누수 버킷 | 출력 처리량 고정 |
| 공개 API에서 공정성이 중요 | 슬라이딩 윈도우 | 경계 악용 방지, 정밀 |
| 결제/주문/로그인 같은 민감 API | 누수 버킷 + 토큰 버킷 | 버스트 허용하되 상한 엄격 |

---

### 7) 운영 팁 (현장감 있는 포인트)
- Rate limit 초과 시 응답은 보통 **429**  
  가능하면 `Retry-After` 같은 재시도 힌트를 제공
- 제한 정책은 “전체 시스템 보호”가 목적이므로  
  정상 사용자 피해를 최소화하도록 점진적으로 조정
- 제한 로그/메트릭을 남겨 “누가/언제/어디서” 차단됐는지 관측 가능하게 설계