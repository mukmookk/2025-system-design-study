# 6장. 분산 캐싱 (Distributed Caching)

## 목차

- [6.1 캐싱 정의](#61-캐싱-정의)
  - [6.1.1 캐시 적용 목적](#611-캐시-적용-목적)
  - [6.1.2 캐시 히트와 미스](#612-캐시-히트와-미스)
- [6.2 분산 캐시 설계](#62-분산-캐시-설계)
  - [6.2.1 로컬 캐시 vs 분산 캐시](#621-로컬-캐시-vs-분산-캐시)
  - [6.2.2 분산 캐시 사용 시 고려사항](#622-분산-캐시-사용-시-고려사항)
    - [캐시 일관성 문제](#1-캐시-일관성-문제)
    - [캐시 패턴 (Caching Patterns)](#2-캐시-패턴-caching-patterns)
    - [캐시 만료 및 제거 정책](#3-캐시-만료-및-제거-정책)
    - [캐시 스탬피드(Cache Stampede)](#4-캐시-스탬피드cache-stampede)
    - [장애 허용성 및 폴백 전략](#5-장애-허용성-및-폴백-전략)
  - [6.2.3 캐시 적용 대상 선정 기준](#623-캐시-적용-대상-선정-기준)
  - [6.2.4 캐시 키 설계 전략](#624-캐시-키-설계-전략)
  - [6.2.5 TTL(Time To Live) 설계 전략](#625-ttltime-to-live-설계-전략)
- [6.3 대표적인 분산 캐시 솔루션](#63-대표적인-분산-캐시-솔루션)
  - [6.3.1 Redis](#631-redis)
  - [6.3.2 Memcached](#632-memcached)
  - [6.3.3 Managed 서비스](#633-managed-서비스)

## 6.1 캐싱 정의

캐싱(Cache)이란 **자주 사용되거나 계산 비용이 큰 데이터의 결과를 임시 저장소에 저장하여,
동일한 요청이 반복될 때 빠르게 응답할 수 있도록 하는 성능 최적화 기법**이다.

캐시는 일반적으로 다음과 같은 특징을 가진다.

- 메모리 기반 저장소 사용
- 원본 데이터 소스(DB, 외부 API 등)보다 빠른 접근 속도
- 데이터의 영구 저장이 목적이 아님
- 일정 시간 이후 데이터 만료(Expiration) 가능

### 6.1.1 캐시 적용 목적

캐싱은 단순한 속도 개선을 넘어 시스템 전체 안정성에 기여한다.

- 응답 지연(latency) 감소
- DB, 외부 API 호출 수 감소
- 트래픽 급증 시 완충 역할 (buffer)
- 시스템 확장 비용 절감

### 6.1.2 캐시 히트와 미스

- **Cache Hit**
  - 요청한 데이터가 캐시에 존재하는 경우
  - 즉시 반환 → 빠른 응답

- **Cache Miss**
  - 캐시에 데이터가 없는 경우
  - 원본 저장소(DB 등) 조회 후 캐시에 저장

캐시 시스템의 효율성은 **Cache Hit Ratio**로 평가된다.

---

## 6.2 분산 캐시 설계

분산 캐시는 **여러 애플리케이션 인스턴스가 네트워크를 통해 공통으로 접근하는 캐시 시스템**이다.  
마이크로서비스 또는 스케일 아웃 환경에서는 사실상 필수적인 구성 요소이다.

### 6.2.1 로컬 캐시 vs 분산 캐시

| 구분 | 로컬 캐시 | 분산 캐시 |
|----|----|----|
| 저장 위치 | 애플리케이션 JVM 내부 | 별도 캐시 서버 |
| 인스턴스 간 공유 | 불가능 | 가능 |
| 응답 속도 | 매우 빠름 | 네트워크 비용 발생 |
| 일관성 | 인스턴스마다 다를 수 있음 | 비교적 일관성 유지 |
| 확장성 | 제한적 | 수평 확장 가능 |

### 6.2.2 분산 캐시 사용 시 고려사항

#### 1) 캐시 일관성 문제

원본 데이터와 캐시 데이터 간 불일치 가능성은 분산 캐시의 핵심 이슈이다.

- 데이터 변경 후 캐시가 즉시 갱신되지 않을 수 있음
- 짧은 시간 동안의 **Stale Data** 허용 여부 판단 필요

**일반적인 해결 방식**
- TTL(Time To Live) 설정
- 명시적 캐시 삭제(Cache Invalidation)
- 쓰기 전략 선택 (Write-Through, Write-Behind)

---

#### 2) 캐시 패턴 (Caching Patterns)

##### Cache Aside (Lazy Loading)

가장 많이 사용되는 패턴

1. 애플리케이션이 캐시 조회
2. Cache Miss 발생
3. DB 조회
4. 결과를 캐시에 저장

**장점**
- 단순하고 유연함
- 캐시 장애 시 DB로 자연스럽게 폴백 가능

**단점**
- 최초 요청은 항상 느림
- 데이터 변경 시 캐시 무효화 필요

---

##### Write Through

- DB에 쓰기 요청 시 캐시에도 동시에 기록

**장점**
- 캐시와 DB 간 일관성 유지
- Cache Miss 감소

**단점**
- 쓰기 성능 저하
- 캐시 장애 시 쓰기 영향 가능

---

##### Write Behind (Write Back)

- 캐시에 먼저 쓰고, DB에는 비동기로 반영

**장점**
- 쓰기 성능 우수

**단점**
- 장애 발생 시 데이터 유실 가능
- 구현 복잡도 높음

---

#### 3) 캐시 만료 및 제거 정책

캐시는 메모리 자원이 제한적이므로 데이터 제거 정책이 필수적이다.

- **TTL (Time To Live)**
  - 일정 시간 이후 자동 만료
- **LRU (Least Recently Used)**
  - 가장 오래 사용되지 않은 데이터 제거
- **LFU (Least Frequently Used)**
  - 사용 빈도가 가장 낮은 데이터 제거

실무에서는 **TTL + LRU 조합**이 가장 흔하다.

---

#### 4) 캐시 스탬피드(Cache Stampede)

여러 요청이 동시에 Cache Miss를 일으켜 DB에 부하가 집중되는 현상이다.

**해결 방법**
- Mutex / Lock 기반 캐시 로딩
- 랜덤 TTL(Randomized Expiration)
- 요청 병합(Request Coalescing)

---

#### 5) 장애 허용성 및 폴백 전략

분산 캐시는 장애가 발생하더라도 **서비스 전체가 중단되지 않도록 설계**해야 한다.

- 캐시 장애 시 DB 직접 조회
- 캐시는 항상 "있으면 좋고 없어도 되는" 구조
- 캐시를 시스템의 Single Point of Failure로 두지 않음

---

### 6.2.3 캐시 적용 대상 선정 기준

모든 데이터를 캐시하는 것은 오히려 시스템 복잡도를 증가시킨다.
따라서 캐시 적용 대상은 명확한 기준을 가지고 선별해야 한다.

**캐시에 적합한 데이터**
- 조회 빈도가 높고 변경 빈도가 낮은 데이터
- 계산 비용이 큰 결과 데이터
- 일관성보다 성능이 더 중요한 데이터
- 약간의 지연된 반영(Stale Data)을 허용할 수 있는 데이터

**캐시에 부적합한 데이터**
- 실시간 정합성이 매우 중요한 데이터 (결제, 잔액 등)
- 변경 빈도가 매우 높은 데이터
- 개인화 데이터 중 보안 민감도가 높은 데이터

캐시는 성능 최적화 수단이지, 데이터 저장소의 대체 수단이 아니다.

### 6.2.4 캐시 키 설계 전략

캐시 시스템에서 키 설계는 성능과 유지보수성에 직접적인 영향을 미친다.

**좋은 캐시 키 설계 원칙**
- 의미가 명확한 네임스페이스 사용
- 충돌 방지
- 버전 관리 가능 구조

**권장 키 패턴 예시**
- user:{userId}
- product:{productId}
- product:list:category:{categoryId}:page:{pageNo}
- auth:token:{tokenId}

**주의 사항**
- 키 길이가 과도하게 길어지지 않도록 주의
- 키에 민감 정보 포함 금지
- 버전 변경 시 key prefix를 통한 일괄 무효화 고려

### 6.2.5 TTL(Time To Live) 설계 전략

TTL은 캐시 데이터의 수명 주기를 제어하는 핵심 요소이다.

**TTL 설정 시 고려사항**
- 데이터 변경 주기
- 허용 가능한 데이터 지연 범위
- 트래픽 패턴

**TTL 설계 예시**
- 자주 변경되는 데이터: 수 초 ~ 수 분
- 통계/집계 데이터: 수 분 ~ 수 시간
- 거의 변경되지 않는 데이터: 수 시간 ~ 하루

#### 랜덤 TTL(Randomized Expiration)

동일한 시점에 대량의 캐시가 만료되어 DB 부하가 폭증하는 현상을 방지하기 위해,
TTL에 무작위 오프셋을 추가할 수 있다.

예:
- 기본 TTL: 300초
- 실제 TTL: 300 ± (0~30초)

## 6.3 대표적인 분산 캐시 솔루션

### 6.3.1 Redis

Redis는 인메모리 기반의 고성능 Key-Value 스토어로,
캐시뿐 아니라 다양한 용도로 활용된다.

**주요 특징**
- 다양한 자료구조 제공
- TTL 및 만료 이벤트 지원
- 복제(Replication) 및 클러스터 구성 가능
- Lua Script 기반 원자적 연산 가능

**장점**
- 범용성 높음
- 커뮤니티 및 레퍼런스 풍부

**단점**
- 메모리 비용 높음
- 영속성 설정 시 성능 영향

---

### 6.3.2 Memcached

Memcached는 **순수 캐싱 목적에 최적화된 분산 캐시 시스템**이다.

**특징**
- 단순 Key-Value 구조
- 매우 빠른 읽기/쓰기
- 영속성, 복제 기능 없음

**적합한 경우**
- 단순 조회 캐시
- 데이터 손실 허용 가능한 경우

---

### 6.3.3 Managed 서비스

- AWS ElastiCache
- GCP Memorystore
- Azure Cache for Redis

**장점**
- 운영 부담 감소
- 고가용성 자동 구성
